<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Document Object]]></title>
    <url>%2F2018%2F07%2F31%2FDom-md%2F</url>
    <content type="text"><![CDATA[This is the learning noets about Dom when I learned from the web site javascript.info DocumentHere’s a bird’s-eye view of what we have when JavaScript runs in a web-browser: javascript DOM (Document Object Model) — The document object gives access to the page content. BOM (Browser Object Model) — navigator object, location object, history object, XMLHttpRequest, etc. DOM TreeAccording to Document Object Model (DOM), every HTML-tag is an object. The text inside a tag it is an object as well. Everything in HTML, even comments, becomes a part of the DOM. There are 12 node types. In practice we usually work with 4 of them: document – the “entry point” into DOM. element nodes – HTML-tags, the tree building blocks. text nodes – contain text. comments. Walking the DOMGiven a DOM node, we can go to its immediate neighbours using navigation properties. There are two main sets of them: For all nodes: parentNode, childNodes, firstChild, lastChild, previousSibling, nextSibling. For element nodes only: parentElement, children, firstElementChild, lastElementChild, previousElementSibling, nextElementSibling. childNodes(children) looks like an array. But actually it’s not an array, but rather a collection – a special array-like iterable object. There are two important consequences: We can use for..of to iterate over it. (Don’t use for..in to loop over collections, The for..in loop iterates over all enumerable properties, and return some “extra” rarely used properties that we usually do not want to get). Array methods won’t work, because it’s not an array. We can use Array.from to create a “real” array from the collection, if we want array methods. DOM collections are read-only; DOM collections are live, in other words, they reflect the current state of DOM. Searching in the DOM Method Searches By… Can call on an element Live? getElementById id - - getElementsByTagName tag ✔ ✔ getElementsByClassName class ✔ ✔ querySelectorAll CSS-selector ✔ - querySelector CSS-selector ✔ - Please note that methods getElementById and getElementsByName can only be called in the context of the document: document.getElementById(...). The call to elem.querySelector(css) returns the first element for the given CSS selector. In other words, the result is the same as elem.querySelectorAll(css)[0], but the latter is looking for all elements and picking one, while elem.querySelector just looks for one. So it’s faster and shorter to write. Besides that: There is elem.matches(css) to check if elem matches the given CSS selector. There is elem.closest(css) to look for the nearest ancestor that matches the given CSS-selector. The elem itself is also checked. Node PropertiesEach DOM node belongs to a certain class. The classes form a hierarchy. The full set of properties and methods come as the result of inheritance. The innerHTML property allows to get the HTML inside the element as a string, we can also modify it. We can append “more HTML” by using elem.innerHTML+=&quot;something&quot;. innerHTML+= does this: The old contents is removed. The new innerHTML is written instead. As the content is “zeroed-out” and rewritten from the scratch, all images and other resources will be reloaded. If the existing text was selected with the mouse, then most browsers will remove the selection upon rewriting innerHTML. And if there was an &lt;input&gt; with a text entered by the visitor, then the text will be removed. And so on. The innerHTML property is only valid for element nodes. Other node types have their counterpart: nodeValue and data(preferred) properties. The textContent provides access to the text inside the element: only text, minus all . With innerHTML we’ll have it inserted “as HTML”, with all HTML tags, while with textContent, we’ll have it inserted “as text”, all symbols are treated literally. In most cases, we expect the text from a user, and want to treat it as text. We don’t want unexpected HTML in our site. An assignment to textContent does exactly that. hidden works the same as style=&quot;display:none&quot;. But it’s shorter to write. Attribute and PropertiesWhen the browser loads the page, it parses HTML text and generates DOM objects from it. For element nodes most standard HTML attributes automatically become properties of DOM objects. When a standard attribute changes, the corresponding property is auto-updated with some exceptions, e.g., input.value synchronizes only from attribute → to property, but not back. There are some differences bewteen them: the style attribute is a string, but the style property is an object, the href DOM property is always a full URL while the attribute is not. All attributes(including nonstandard attribute) are accessible using following methods: elem.hasAttribute(name) – checks for existence. elem.getAttribute(name) – gets the value. elem.setAttribute(name, value) – sets the value. elem.removeAttribute(name) – removes the attribute. All attributes starting with “data-” are reserved for programmers’ use. They are available in the dataset property. Multiword attributes like data-order-state become camel-cased: dataset.orderState. Modifying the documentMethods to create new nodes: document.createElement(tag) – creates an element with the given tag, document.createTextNode(value) – creates a text node (rarely used), elem.cloneNode(deep) – clones the element, if deep==true then with all descendants. Insertion and removal of nodes: From the parent: parent.appendChild(node) parent.insertBefore(node, nextSibling) parent.removeChild(node) parent.replaceChild(newElem, node) All these methods return node. Given a list of nodes and strings: node.append(...nodes or strings) – insert into node, at the end, node.prepend(...nodes or strings) – insert into node, at the beginning, node.before(...nodes or strings) –- insert right before node, node.after(...nodes or strings) –- insert right after node, node.replaceWith(...nodes or strings) –- replace node. node.remove() –- remove the node. Text strings are inserted “as text”. Given a piece of HTML: elem.insertAdjacentHTML(where, html), inserts depending on where: “beforebegin” – insert html right before elem, “afterbegin” – insert html into elem, at the beginning, “beforeend” – insert html into elem, at the end, “afterend” – insert html right after elem. Also there are similar methods elem.insertAdjacentText and elem.insertAdjacentElement, they insert text strings and elements, but they are rarely used. Styles and classesTo manage classes, there are two DOM properties: className and classList. If we assign something to elem.className, it replaces the whole strings of classes. Sometimes that’s what we need, but often we just want to add/remove a single class. There’s another property for that: elem.classList. The elem.classList is a special object with methods to add/remove/toggle classes. Methods of classList: elem.classList.add/remove(&quot;class&quot;) – adds/removes the class. elem.classList.toggle(&quot;class&quot;) – if the class exists, then removes it, otherwise adds it. elem.classList.contains(&quot;class&quot;) – returns true/false, checks for the given class. The property elem.style is an object that corresponds to what’s written in the “style” attribute. For multi-word property the camelCase is used: border-left-width =&gt; elem.style.borderLeftWidth, browser-prefixed properties like -moz-border-radius =&gt;button.style.MozBorderRadius(a dash “-“ becomes an uppercase). CSS units must be provided in style values. For instance, we should not set elem.style.top to 10, but rather to 10px, otherwise it wouldn’t work. Modifying a style is easy. But how to read it? The style property operates only on the value of the “style” attribute, without any CSS cascade. There’s another method for that: getComputedStyle. To read the resolved styles (with respect to all classes, after all CSS is applied and final values are calculated): The getComputedStyle(elem[, pseudo]) returns the style-like object with them. (Read-only; returns the resolved value; requires the full property name) Element size and scrollingElements have the following geometry properties: offsetParent – is the nearest positioned ancestor or td, th, table, body. offsetLeft/offsetTop – coordinates relative to the left-upper edge of offsetParent. offsetWidth/offsetHeight – “outer” width/height of an element including borders. clientLeft/clientTop – the distance from the left-upper outer corner to its left-upper inner corner. For left-to-right OS they are always the widths of left/top borders. For right-to-left OS the vertical scrollbar is on the left so clientLeft includes its width too. clientWidth/clientHeight – the width/height of the content including paddings, but without the scrollbar. scrollWidth/scrollHeight – the width/height of the content including the scrolled out parts. Also includes paddings, but not the scrollbar. scrollLeft/scrollTop – width/height of the scrolled out part of the element, starting from its left-upper corner. All properties are read-only except scrollLeft/scrollTop. They make the browser scroll the element if changed. Don’t take width/height from CSS. We can read CSS-height and width using getComputedStyle. Why should we use geometry properties instead? There are two reasons: CSS width/height depend on another property: box-sizing, CSS width/height may be auto. Some browsers (e.g. Chrome) return the real inner width, minus the scrollbar, and some of them (e.g. Firefox) – CSS width (ignore the scrollbar). Such cross-browser differences is the reason not to use getComputedStyle, but rather rely on geometry properties. Window sizes and scrollingGeometry: Width/height of the visible part of the document (content area width/height): document.documentElement.clientWidth/Height Width/height of the whole document, with the scrolled out part: 12345let scrollHeight = Math.max( document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight); Scrolling: Most browsers provide documentElement.scrollLeft/Top for the document scroll, but Chrome/Safari/Opera have bugs and we should use document.body instead of document.documentElement there. Luckily, we don’t have to remember these peculiarities at all, because of the following special properties: Read the current scroll: window.pageYOffset/pageXOffset. Change the current scroll: window.scrollTo(pageX,pageY) – absolute coordinates, window.scrollBy(x,y) – scroll relative the current place, elem.scrollIntoView(top) – scroll to make elem visible (align with the top/bottom of the window). CoordinatesAny point on the page has coordinates: Relative to the window – elem.getBoundingClientRect(). Relative to the document – elem.getBoundingClientRect() plus the current page scroll window.pageXOffset/pageYOffset. Window coordinates are great to use with position:fixed, and document coordinates do well with position:absolute. Both coordinate systems have their “pro” and “contra”, there are times we need one or the other one, just like CSS position absolute and fixed. Words and phrases: out of nowhere 莫名其妙的出现 superposition 叠加]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Arch Linux]]></title>
    <url>%2F2018%2F07%2F18%2FArchlinux%2F</url>
    <content type="text"><![CDATA[Dual Booting Arch Linux / Windows 10 On Surface Pro Device: Surface Pro 2017 OS: Windows 10 / Arch Linux 2018.05.01 Method: USB Installer 准备工作熟悉 Vim. 压缩卷右键开始 –&gt; 磁盘管理(K) –&gt; 选择主分区 –&gt; 压缩卷 –&gt; 分出 40 G. 制作启动盘下载 Arch Linux 和 Rufus 并制作好启动盘（选择 UEFI, PT). 设置从 USB 启动首先按住音量键并启动, 入 UEFI, 闭安全启动, 将启动顺序改为从 USB 启动. 插入 USB 后 Reboot 就能从 USB 启动 Arch Linux. 选择第一个选项进入系统. 安装过程安装过程需要使用网络. 用数据线连接手机, 开USB网络共享. 设置屏幕字体大小由于分辨率太高, 致字体显示太小, 新设置终端字体 1# setfont /usr/share/kbd/consolefonts/latarcyrheb-sun32.psfu.gz 测试网络连接 123# dhcpcd# ping -c 3 www.baidu.com // 成功接收到数据包则连接成功# timedatectl set-ntp true 分区 12345678# fdisk -l // 以下是一个输出实例nvme0n1 259:0 0 238.5G|- nvme0n1p1 259:1 0 260M|- nvme0n1p2 259:2 0 128M|- nvme0n1p3 259:3 0 174.8G|- nvme0n1p4 259:4 0 830M# gdisk /dev/nvme0n1（ 1. n(new) 2. 在last sector时 +20G, 其余回车, 择默认设置 3. n 回车选择默认设置, 出第6部分 4. p 看是否分区成功 5. w(write) Y(Yes) 格式化 12# mkfs.ext4 /dev/nvme0n1p5# mkfs.ext4 /dev/nvme0n1p6 挂载 12345# mount /dev/nvme0n1p5 /mnt# mkdir /mnt/home# mount /dev/nvme0n1p6 /mnt/home# mkdir -p /mnt/boot/efi // 创建 UEFI 挂载点# mount /dev/nvme0n1p1 /mnt/boot/efi // 挂载 UEFI 分区 安装 base 12345# vi /etc/pacman.d/mirrorlist //把163的提到第一个# pacstrap -i /mnt base base-devel# genfstab -U /mnt &gt;&gt; /mnt/etc/fstab# cat /mnt/etc/fstab# arch-chroot /mnt 安装 grub 123# pacman -S dosfstools grub efibootmgr os-prober(双系统必装)# grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=grub# grub-mkconfig -o /boot/grub/grub.cfg //(reboot 后还要运行一次, 行结果才会出现windows manager) 重启 reboot 12345# passwd // 设置 root 密码# CTRL-D // exit# umount /mnt/boot/efi# umount /mnt# reboot // 记得移除 USB 基本设置重启后用 root 身份登录, 修改显示字体, 开手机网络共享, 试网络.123# setfont /usr/share/kbd/consolefonts/latarcyrheb-sun32.psfu.gz# dhcpcd# ping -c 3 www.baidu.com // 成功接收到数据包则连接成功 时区 1# ln -S /usr/share/zoneinfo/Asia/Shanghai /etc/localtime Locale 12345# vi /etc/locale.gen // 移除下面两行前的注释符号en\_US.UTF-8 UTF-8zh\_CN.UTF-8 UTF-8# locale-gen# echo LANG=en_US.UTF-8 &gt; /etc/locale.conf hostname 123456789# echo Arch &gt; /etc/hostname //将主机名Arch填入# vi /etc/hosts // 修改 host完成后看起来像这样:# cat /etc/hostnameArch# cat /etc/hosts127.0.0.1 localhost.localdomain localhost::1 localhost.localdomain localhost127.0.1.1 Arch.localdomain Arch 时间时间表示有两个标准：Localtime 和 UTC(Coordinated Universal Time). UTC 是与时区无关的全球时间标准. 尽管概念上有差别, UTC 和 GMT (格林威治时间) 是一样的. Localtime 标准则依赖于当前时区. 由于 windows 使用 Localtime, 为了保持一致: 12# timedatectl set-local-rtc true // 将硬件时间设置为 localtime# hwclock --systohc // 同步硬件时间和系统时间 网络 123# systemctl enable dhcpcd# pacman -S networkmanager iw wpa_supplicant dialog# systemctl enable NetworkManager 显卡, Touchpad 驱动 12# pacman -S xf86-video-intel# pacman -S xf86-input-libinput gnome 12# pacman -S gnome gnome-tweaks# systemctl enable gdm 重启后 gnome 启动, 登录 root 账户, 在 account setting 中 add users 后, log out 重新以 user 的身份登录. gnome 设置 Touchpad 左键使用不习惯.setting –&gt; devices –&gt; mouse and touchpad –&gt; tab to click;tweaks –&gt; mouse &amp; touchpad –&gt; Mouse click emulation (Area). sudo 12$ sudo pacman -S sudo vim$ visudo //（在 root ALL=(ALL)下面仿照格式把root 改成 username） 添加 archlinuxcn 源 123456$ sudo vim /etc/pacman.conf // 添加以下几行[archlinuxcn]#The Chinese Arch Linux communities packages.SigLevel = Optional TrustAllServer = http://repo.archlinuxcn.org/$arch$ sudo pacman -Syu 搜狗拼音 12345$ sudo pacman -S fcitx-im fcitx-configtool fcitx-sogoupinyin$ sudo vim /etc/environment // 写入export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=@im=fcitx 然后还需要修改 fcitx-configtool 中的设置: Default Keyboard Layout –&gt; 选择 Chinese, 添加 –&gt; Add input method（+号）选择 Sougou Pinyin. chrome 123$ sudo pacman -S wqy-microhei wqy-zenhei yaourt// 字体$ sudo yaourt -S google-chrome // 如果root账号下安装 chrome, chrome 无法启动.$ sudo pacman -R epiphany shadowsocks 1$ sudo pacman -S shadowsocks-qt5 设置好 shadowsock 后, 还需要 setting –&gt; Network –&gt; Network Proxy –&gt; Manual –&gt; Socks Host 127.0.0.1 1080（设置的local端口号）. 桌面美化 下载extensions, 解压缩后, 放到路径：~/.local/share/gnome-shell/extensions/下载Gnome-OSC, 解压缩后, 把里面两个文件, 放到路径：home/.themes/下,下载macOS iCons, 解压缩后, 放到路径：home/.icons/下.重新登录后(重启？), 利用 tweaks 进行设置. 解决休眠问题 123$ sudo vim /etc/systemd/logind.confHandleLidSwitch=ignore$ systemctl restart systemd-logind setting –&gt; power, 关闭 atutosuspend, dim screen.]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
</search>
