<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Browser Events]]></title>
    <url>%2F2018%2F08%2F28%2FEvents%2F</url>
    <content type="text"><![CDATA[Introducton to Browser Events. Assign event handlersThere are 3 ways to assign event handlers: HTML attribute: onclick=&quot;...&quot;. A handler can be set in HTML with an attribute named on&lt;event&gt;. As we know, HTML attribute names are not case-sensitive, so onclick is not case-sensitive. DOM property: elem.onclick = function. We can assign a handler using a DOM property on&lt;event&gt;. As there’s only one onclick property, we can’t assign more than one event handler. To remove a handler – assign elem.onclick = null. Using elem.addEventListener(event, handler[, phase])to add, removeEventListener to remove. Multiple calls to addEventListener allow to add multiple handlers. There are few events that only work with it, for instance transtionend and DOMContentLoaded (to be covered). Also addEventListener supports objects and classes as event handlers. In that case the method handleEvent is called in case of the event. When an event happens, the browser creates an event object, puts details into it and passes it as the first argument to the handler. Some properties of event object: event.type Event type, such as “click”. event.currentTarget Element that handled the event. That’s exactly the same as this. event.clientX / event.clientY Window-relative coordinates of the cursor, for mouse events. The value of this inside a handler is the element. The one which has the handler on it. Bubbling and capturingThe event handling process: When an event happens – the most nested element where it happens gets labeled as the “target element” (event.target). Capturing phase - Then the event first moves from the document root down the event.target, calling handlers assigned with addEventListener(...., true) on the way. Target phase – the event reached the target element. Bubbling phase - Then the event moves from event.target up to the root, calling handlers assigned using on&lt;event&gt; and addEventListener without the 3rd argument or with the 3rd argument false. event.target – the deepest element that originated the event. event.currentTarget (=this) – the current element that handles the event (the one that has the handler on it). Any event handler can stop the event by calling event.stopPropagation(). Almost all events bubble. The key word in this phrase is “almost”. For instance, a focus event does not bubble. Event delegationEvent delegation is often used to add same handling for many similar elements, but not only for that.The algorithm: Put a single handler on the container. In the handler – check the source element event.target. If the event happened inside an element that interests us, then handle the event. Benefits: Simplifies initialization and saves memory: no need to add many handlers. Less code: when adding or removing elements, no need to add/remove handlers. DOM modifications: we can mass add/remove elements with innerHTML and alike. Limitations: the event must be bubbling. Some events do not bubble. Also, low-level handlers should not use event.stopPropagation(). the delegation may add CPU load, because the container-level handler reacts on events in any place of the container, no matter if they interest us or not. But usually the load is negligible, so we don’t take it into account. Browser default actionsThere are many default browser actions: A click on a link – initiates going to its URL. A click on submit button inside a form – initiates its submission to the server. To prevent a default action – use either event.preventDefault() or return false. The second method works only for handlers assigned with on&lt;event&gt;. Dispatching custom eventsCreate a general Event:1let event = new Event(event type[, options]); Arguments: event type - may be any string, like “click” or our own like “hey-ho!”. options – the object with two optional properties: bubbles: true/false – if true, then the event bubbles. cancelable: true/false – if true, then the “default action” may be prevented. By default both are false: {bubbles: false, cancelable: false}. After an event object is created, we should dispatch it on an element using the call elem.dispatchEvent(event). We should use addEventListener for our custom events, because on only exists for built-in events. For some UI Events, such as FocusEvent, MouseEvent, we should use something likenew MouseEvent(&quot;click&quot;) instead of new Event, since they provide specify standard properties for that type of event, like clientX/clientY for a mouse event. For our own, custom events like “hello” we should use new CustomEvent. It provides a second argument detail, which is an object designed for any custom information that we want to pass with the event. We can call event.preventDefault() on a script-generated event if cancelable:true flag is specified. In that case the call to elem.dispatchEvent(event) returns false. Mouse eventsMouse event types: simple: mousedown/mouseup, mouseover/mouseout, mousemove. complex: click, contextmenu(click right mouse button), dblclick(double click). An action may trigger multiple events. For instance, a click first triggers mousedown, when the button is pressed, then mouseup and click when it’s released. The handlers are called in the order mousedown → mouseup → click. Both click and contextmenu trigger mousedonw and mouseup. which allows to distinguish between “right-mousedown” and “left-mousedown”: event.which == 1 – the left button, event.which == 2 – the middle button, event.which == 3 – the right button. All mouse events include the information about pressed modifier keys: shiftKey, altKey, ctrlKey, metaKey (Cmd for Mac). All mouse events have coordinates in two flavours: Window-relative: clientX and clientY. Document-relative: pageX and pageY. We covered events mouseover, mouseout, mousemove, mouseenter and mouseleave. Things that are good to note: Events mouseover/out trigger even when we go from the parent element to a child element. They assume that the mouse can be only over one element at one time – the deepest one. Events mouseenter/leave do not bubble and do not trigger when the mouse goes to a child element. They only track whether the mouse comes inside and outside the element as a whole. A fast mouse move can make mouseover, mousemove, mouseout to skip intermediate elements. Events mouseover/out and mouseenter/leave have an additional target: relatedTarget. That’s the element that we are coming from/to, complementary to target. Keyboard eventsPressing a key always generates a keyboard event.Keyboard events: keydown – on pressing the key (auto-repeats if the key is pressed for long), keyup – on releasing the key. Main keyboard event properties: event.code – the “key code”, specific to the physical location of the key on keyboard. event.key – the character (“A”, “a” and so on), it’s a specific value. Let’s say, we want to handle a hotkey: Ctrl+Z (or Cmd+Z for Mac). We can set a listener on keydown and check which key is pressed – to detect when we have the hotkey. Please answer the question – in such a listener, should we check the value of event.key or event.code? (The answer is event.code.) Page lifecycle eventsPage lifecycle events: DOMContentLoaded event triggers on document when DOM is ready. Images and other resources may still continue loading. load event on window triggers when the page and all resources are loaded. onunload 和 onbeforeunload 两个事件都是在执行页面刷新、关闭、浏览器关闭时能触发, onunload 是在服务器上已经读取到数据, 将要替换当前页面时执行, 一般用于当离开页面以后执行的动作. onbeforeunload 是正要向服务器读取新的页面时执行的动作，此事件执行在访问服务器事件之前, 一般用于提醒你是否要离开页面. document.readyState is the current state of the document, changes can be tracked in the readystatechange event: loading – the document is loading. interactive – the document is parsed, happens at about the same time as DOMContentLoaded, but before it. complete – the document and resources are loaded, happens at about the same time as window.onload, but before it. Resource loading eventsThe browser allows to track the loading of external resources – scripts, iframes, pictures and so on.There are two events for it: onload – successful load, onerror – an error occurred. Only load event when the iframe loading finished. It triggers both for successful load and in case of an error. That’s for historical reasons. Forms eventsForm navigation: A form is available as document.forms[name/index]. Form elements are available as form.elements[name/index], or can use just form[name/index]. Elements reference their form in the form property. For details, you can read the article. An element receives a focus when the user either clicks on it or uses the Tab key on the keyboard. When a user clicks somewhere else or presses Tab to go to the next form field, it triggers the event losing the focus (“blur”). The focus event is called onfocus, and onblur – when the element loses the focus. Methods elem.focus() and elem.blur() set/unset the focus on the element. Events focus and blur do not bubble, but but propagate down on the capturing phase. For delegation purpose, you can use focusin/focusout. Let’s discuss various events that accompany data updates. The change event triggers when the element has finished changing. For text inputs that means that the event occurs when it looses focus, instead the input event triggers every time a value is modified. The submit event triggers when the form is submitted, it is usually used to validate the form before sending it to the server or to abort the submission and process it in JavaScript. To submit a form to the server manually, we can call form.submit(). Then the submit event is not generated.]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2F2018%2F08%2F11%2Fgit%2F</url>
    <content type="text"><![CDATA[Learning note of Git. 开始 配置用户名和邮箱 123$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot;$ git config --list // 查看配置信息 创建版本库 123$ mkdir &lt;dirname&gt;$ cd &lt;dirname&gt;$ git init // 创建一个版本库 当前目录下多了一个 .git 的目录, 这个目录是 Git 用来跟踪管理版本库的, 不要手动修改这个目录里面的文件. 工作区和暂存区 http://www.runoob.com/wp-content/uploads/2015/02/1352126739_7909.jpg 工作区 (Working Directory) 就是你工作的目录. 工作区有一个隐藏目录 .git, 这个不算工作区, 而是 Git 的版本库 (Repository). Git 的版本库里存了很多东西, 其中 .git/index 文件夹称为暂存区, 它实际上就是一个包含文件索引的目录树, 文件的内容并不存储其中, 而是保存在 Git 对象库 .git/objects 中. Git 还为我们自动创建的第一个分支 master, 以及指向 master 的一个指针叫 HEAD. 工作区、暂存区和版本库都各自维持着一棵目录树, 初始状态三者一致. - git add 后同步工作区和暂存区的目录树, git commit 后同步暂存区和版本库的目录树. - git diff 比较的是工作区和暂存区, git diff –-cached 比较的是暂存区和版本库的差别, git diff HEAD 比较的是工作区和版本库的差别. - git reset HEAD：暂存区的目录树会被重写为 HEAD 指向的分支的目录树, 但是工作区的目录树不受影响, git reset --hard后工作区, 暂存区的目录树都被重写. - git checkout -- &lt;file&gt; 会用暂存区指定的文件替换工作区的文件, git checkout HEAD &lt;file&gt; 会用 HEAD 指向的文件替换暂存区和工作区中的文件. - git rm &lt;file&gt; = rm &lt;file&gt; + git add &lt;file&gt;应用场景- 版本回退 每当你觉得文件修改到一定程度的时候, 就可以“保存一个快照”, 这个快照在 Git 中被称为 commit. 一旦你把文件改乱了, 或者误删了文件, 可以从最近的 commit 恢复, 然后继续工作. 要回退到之前的版本, 首先 Git 必须知道当前版本是哪个版本. 在 Git 中, 用 HEAD 表示当前版本, 上一个版本就是 HEAD^, 上上一个版本就是 HEAD^^, 往上 n 个版本写成 HEAD~n. 或者查看 commit id, 1234$ git log // 可以查看所有的历史提交$ git log --pretty=oneline // 更简洁的输出// 输出的 commit id 是一个由 SHA1 计算出来的一个非常大的十六进制数字.$ git reset --hard HEAD^ // 回退到上一个版本 如果我们后悔了, 想回到最后的版本, 则需要知道最后版本的 commit id. 如果使用 git log 是不行的, 因为他输出的只是截至当前版本的历史提交. 12$ git reflog // 记录了每次使用过的指令, 因此可以看到每个提交的 id$ git reset --hard &lt;commit id&gt; // 只需要前几位就可以了- 撤销修改 当你对工作区某个文件作了大量改动, 却想全部丢弃工作区的修改时, 可以用命令 git checkout -- file. 当你误删除了一个文件时想要恢复时也可以用 git checkout -- file; 当你不但改乱了工作区某个文件的内容, 而且已经添加到了暂存区时, 想丢弃修改, 第一步用命令 git reset HEAD &lt;file&gt;, 就回到了上面的情况.## 分支管理分支策略在实际开发中, 我们应该按照几个基本原则进行分支管理： 首先, master 分支应该是非常稳定的, 也就是仅用来发布新版本, 平时不能在上面干活; 那在哪干活呢? 干活都在 dev 分支上, 也就是说, dev 分支是不稳定的, 到某个时候, 比如 1.0 版本发布时, 再把 dev 分支合并到 master 上, 在 master 分支发布 1.0 版本； 你和你的小伙伴们每个人都在 dev 分支上干活, 每个人都有自己的分支, 时不时地往 dev 分支上合并就可以了. 所以, 团队合作的分支看起来就像这样:https://cdn.liaoxuefeng.com/cdn/files/attachments/001384909239390d355eb07d9d64305b6322aaf4edac1e3000/0创建分支master 指针指向主分支的最新提交, HEAD 指针指向当前分支的最新提交.1234$ git branch &lt;branch&gt; // 创建分支, 也即是创造另一个指针$ git checkout &lt;branch&gt; // 切换分支, 也即是把 HEAD 指向分支指针// 以上两步可以合并成 git checkout -b &lt;branch&gt;$ git branch // 列出所有分支合并分支3种合并方式：Fast-forward, non fast-forward, rebase.如果 master 上没有提交, 这种合并方式叫做 Fast-forward(加上 --no-ff 参数就可以强制用 non fast-forward 方式合并).如果主分支和分支上都有新的提交, 并且两种提交有冲突, 合并后自动生成一个提交, 需要手动解决冲突, 再提交, 提交后会重新创建合并修改的提交记录, 这种合并方式叫做 non fast-forward. 合并后的历史有分支, 能看出来曾经做过合并, 而 fast forward 合并就看不出来曾经做过合并.在分支上作完修改并提交后, 要合并到 master 主分支, 需要先切换到 master 分支.12345678$ git checkout master$ git merge &lt;branch&gt; // 合并分支到当前分支// 有冲突需要手动解决冲突// git merge --no-ff -m &lt;message&gt; &lt;branch&gt; 强制使用 non fast-forward// non fast-forward 合并自动生成一个提交, -m 可以添加提交信息$ git branch -d &lt;branch&gt; // 删除分支$ git log --graph --pretty=oneline --abbrev-commit// 可以查看分支的合并情况reabase如下图所示, bugfix 分支是从 master 分支分叉出来的. 之后 master 上增加了修改: C 和 D, 而我们的分支想要建立在 C 和 D 的基础上, 也就是说本来我们是基于提交 B 的, 现在想要基于 C 和 D, 这种情况叫做 rebase. 使用 rebase 方法进行分支合并, 会出现下图所显示的历史记录. 首先, rebase bugfix 分支到 master 分支, bugfix 分支的历史记录会添加在 master 分支的后面, 但是此时 X’ 和 Y’ 是从 X 和 Y 复制过来的, 不再是 X 和 Y 了. 如图所示, 历史记录成一条线. 此时如果继续提交 X’ 和 Y’ 有可能会发生冲突, 所以仍然需要解决冲突. rebase 之后, master 的 HEAD 位置不变. 因此, 要合并 master 分支和 bugfix 分支, 即是将 master 的 HEAD 移动到 bugfix 的 HEAD 这里. 1234567$ git checkout bugfix$ git rebase master // 将当前分支 rebase 到 master 分支$ git rebase --continue// rebase 的时候, 修改冲突后的提交不是使用 commit 命令,// 而是执行 rebase 命令指定 --continue 选项.$ git checkout master$ git merge bugfix 应用场景 多人协作 多人协作的工作模式通常是这样： 首先, 可以试图用 git push origin &lt;branch-name&gt; 推送自己的修改; 如果推送失败, 则因为远程分支比你的本地更新, 需要先用 git pull = git fetch + git merge 试图合并; 如果 git pull 提示 no tracking information, 则说明本地分支和远程分支的链接关系没有创建, 用命令 git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;. 如果合并有冲突, 则解决冲突, 并在本地提交; 没有冲突或者解决掉冲突后, 再用 git push origin &lt;branch-name&gt; 推送就能成功! 修复 bug 假设你手头上的工作正进行到一半, 这时候接到一个修改 bug 的任务, 利用 git stash 可以把当前工作现场“储藏”起来, 等以后恢复现场后继续工作. 然后到 master 分支去创建 bug 分支, 完成后合并到 master 分支. 最后回到之前工作的分支 git stash pop 恢复工作现场. Feature 分支 开发一个新 feature, 最好新建一个分支； 如果要丢弃一个没有被合并过的分支, 可以通过 git branch -D &lt;name&gt; 强行删除. 标签 命令 作用 git tag [tagname] 对某个提交新建一个标签, 默认为 HEAD, 也可以指定 commit id git tag 查看所有标签 git show [tagname] 显示 tag 的信息 git push origin [tagname] 可以推送一个本地标签 git tag -d [tagname] 删除一个本地标签 git push origin :refs/tags/[tagname] 如果标签已经推送到远程, 要删除远程标签,先从本地删除. 然后用这个命令删除远程标签 Github首先注册一个 Github 账号. 配置 SSH这样 push 时就不同每次都要输入密码. 为什么 GitHub 需要 SSH Key 呢? 因为 GitHub 需要识别出你推送的提交确实是你推送的, 而不是别人冒充的, 而 Git 支持 SSH 协议, 所以 GitHub 只要知道了你的公钥, 就可以确认只有你自己才能推送. 12345$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;// 生成私钥和公钥, 可以在用户主目录里找到 .ssh 目录, 里面有 id_rsa 和 id_rsa.pub 两个文件// id_rsa是私钥, 不能泄露出去, id_rsa.pub是公钥.$ cat ~/.ssh/id_rsa.pub// 将输出复制到 GitHub 的 Account settings 的 SSH Keys 里. 同步本地 Git 仓库与远程 GitHub 仓库.假设本地有一个仓库, 可以在 Github 上也创建了一个同名仓库, 然后将两者关联起来: 12$ git remote add origin git@github.com:&lt;AccountName&gt;/learngit.git // 关联$ git push -u origin master // 推送 git push 命令实际上是把当前分支 master 推送到远程. 由于远程库是空的, 我们第一次推送 master 分支时, 加上了 -u 参数, Git 不但会把本地的 master 分支内容推送的远程新的 master 分支, 还会把本地的 master 分支和远程的 master 分支关联起来, 在以后的推送或者拉取时就可以简化命令, 以后只需要使用 git push origin master. 当你第一次使用 Git 的 clone 或者 push 命令连接 GitHub 时, 会得到一个 SSH 警告, 输入 yes 回车即可, 这个警告只会出现一次, 后面的操作就不会有任何警告了. Github 的基本使用如何参与一个开源项目呢(比如人气极高的 Bootstrap 项目)? 点 Fork 就在自己的账号下克隆了一个 Bootstrap 仓库, 然后从自己的账号下clone: git clone git@github.com:&lt;AccountName&gt;/bootstrap.git.Bootstrap 的官方仓库 twbs/bootstrap、你在 GitHub 上克隆的仓库 my/bootstrap, 以及你自己克隆到本地电脑的仓库, 他们的关系就像下图显示的那样： 然后在本地修改一个 Bug, 推送到 Github 仓库, 如果你希望 Bootstrap 的官方库能接受你的修改, 你就可以在 GitHub 上发起一个 pull request. 参考 Git 教程 猴子都能懂的 Git 入门]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Document Object]]></title>
    <url>%2F2018%2F07%2F31%2FDom%2F</url>
    <content type="text"><![CDATA[This is a learning note about Dom, the material is from the web site javascript.info. DocumentHere’s a bird’s-eye view of what we have when JavaScript runs in a web-browser: javascript DOM (Document Object Model) — The document object gives access to the page content. BOM (Browser Object Model) — navigator object, location object, history object, XMLHttpRequest, etc. DOM TreeAccording to Document Object Model (DOM), every HTML-tag is an object. The text inside a tag it is an object as well. Everything in HTML, even comments, becomes a part of the DOM. There are 12 node types. In practice we usually work with 4 of them: document – the “entry point” into DOM. element nodes – HTML-tags, the tree building blocks. text nodes – contain text. comments. Walking the DOMGiven a DOM node, we can go to its immediate neighbours using navigation properties. There are two main sets of them: For all nodes: parentNode, childNodes, firstChild, lastChild, previousSibling, nextSibling. For element nodes only: parentElement, children, firstElementChild, lastElementChild,previousElementSibling, nextElementSibling. childNodes(children) looks like an array. But actually it’s not an array, but rather a collection – a special array-like iterable object. There are two important consequences: We can use for..of to iterate over it. (Don’t use for..in to loop over collections, The for..in loop iterates over all enumerable properties, and return some “extra” rarely used properties that we usually do not want to get). Array methods won’t work, because it’s not an array. We can use Array.from to create a “real” array from the collection, if we want array methods. DOM collections are read-only; DOM collections are live, in other words, they reflect the current state of DOM. Searching in the DOM Method Searches By… Can call on an element Live? getElementById id - - getElementsByTagName tag ✔ ✔ getElementsByClassName class ✔ ✔ querySelectorAll CSS-selector ✔ - querySelector CSS-selector ✔ - Please note that methods getElementById and getElementsByName can only be called in the context of the document: document.getElementById(...). The call to elem.querySelector(css) returns the first element for the given CSS selector. In other words, the result is the same as elem.querySelectorAll(css)[0], but the latter is looking for all elements and picking one, while elem.querySelector just looks for one. So it’s faster and shorter to write. Besides that: There is elem.matches(css) to check if elem matches the given CSS selector. There is elem.closest(css) to look for the nearest ancestor that matches the given CSS-selector. The elem itself is also checked. Node PropertiesEach DOM node belongs to a certain class. The classes form a hierarchy. The full set of properties and methods come as the result of inheritance. The innerHTML property allows to get the HTML inside the element as a string, we can also modify it. We can append “more HTML” by using elem.innerHTML+=&quot;something&quot;. innerHTML+= does this: The old contents is removed. The new innerHTML is written instead. As the content is “zeroed-out” and rewritten from the scratch, all images and other resources will be reloaded. If the existing text was selected with the mouse, then most browsers will remove the selection upon rewriting innerHTML. And if there was an &lt;input&gt; with a text entered by the visitor, then the text will be removed. And so on. The innerHTML property is only valid for element nodes. Other node types have their counterpart: nodeValue and data(preferred) properties. The textContent provides access to the text inside the element: only text, minus all . With innerHTML we’ll have it inserted “as HTML”, with all HTML tags, while with textContent, we’ll have it inserted “as text”, all symbols are treated literally. In most cases, we expect the text from a user, and want to treat it as text. We don’t want unexpected HTML in our site. An assignment to textContent does exactly that. hidden works the same as style=&quot;display:none&quot;. But it’s shorter to write. Attribute and PropertiesWhen the browser loads the page, it parses HTML text and generates DOM objects from it. For element nodes most standard HTML attributes automatically become properties of DOM objects. When a standard attribute changes, the corresponding property is auto-updated with some exceptions, e.g., input.value synchronizes only from attribute → to property, but not back. There are some differences bewteen them: the style attribute is a string, but the style property is an object, the href DOM property is always a full URL while the attribute is not. All attributes(including nonstandard attribute) are accessible using following methods: elem.hasAttribute(name) – checks for existence. elem.getAttribute(name) – gets the value. elem.setAttribute(name, value) – sets the value. elem.removeAttribute(name) – removes the attribute. All attributes starting with “data-” are reserved for programmers’ use. They are available in the dataset property. Multiword attributes like data-order-state become camel-cased: dataset.orderState. Modifying the documentMethods to create new nodes: document.createElement(tag) – creates an element with the given tag, document.createTextNode(value) – creates a text node (rarely used), elem.cloneNode(deep) – clones the element, if deep==true then with all descendants. Insertion and removal of nodes: From the parent: parent.appendChild(node) parent.insertBefore(node, nextSibling) parent.removeChild(node) parent.replaceChild(newElem, node) All these methods return node. Given a list of nodes and strings: node.append(...nodes or strings) – insert into node, at the end, node.prepend(...nodes or strings) – insert into node, at the beginning, node.before(...nodes or strings) –- insert right before node, node.after(...nodes or strings) –- insert right after node, node.replaceWith(...nodes or strings) –- replace node. node.remove() –- remove the node. Text strings are inserted “as text”. Given a piece of HTML: elem.insertAdjacentHTML(where, html), inserts depending on where: “beforebegin” – insert html right before elem, “afterbegin” – insert html into elem, at the beginning, “beforeend” – insert html into elem, at the end, “afterend” – insert html right after elem. Also there are similar methods elem.insertAdjacentText and elem.insertAdjacentElement, they insert text strings and elements, but they are rarely used. Styles and classesTo manage classes, there are two DOM properties: className and classList. If we assign something to elem.className, it replaces the whole strings of classes. Sometimes that’s what we need, but often we just want to add/remove a single class. There’s another property for that: elem.classList. The elem.classList is a special object with methods to add/remove/toggle classes. Methods of classList: elem.classList.add/remove(&quot;class&quot;) – adds/removes the class. elem.classList.toggle(&quot;class&quot;) – if the class exists, then removes it, otherwise adds it. elem.classList.contains(&quot;class&quot;) – returns true/false, checks for the given class. The property elem.style is an object that corresponds to what’s written in the “style” attribute. For multi-word property the camelCase is used: border-left-width =&gt; elem.style.borderLeftWidth, browser-prefixed properties like -moz-border-radius =&gt;button.style.MozBorderRadius(a dash “-“ becomes an uppercase). CSS units must be provided in style values. For instance, we should not set elem.style.top to 10, but rather to 10px, otherwise it wouldn’t work. Modifying a style is easy. But how to read it? The style property operates only on the value of the “style” attribute, without any CSS cascade. There’s another method for that: getComputedStyle. To read the resolved styles (with respect to all classes, after all CSS is applied and final values are calculated): The getComputedStyle(elem[, pseudo]) returns the style-like object with them. (Read-only; returns the resolved value; requires the full property name) Element size and scrollingElements have the following geometry properties: offsetParent – is the nearest positioned ancestor or td, th, table, body. offsetLeft/offsetTop – coordinates relative to the left-upper edge of offsetParent. offsetWidth/offsetHeight – “outer” width/height of an element including borders. clientLeft/clientTop – the distance from the left-upper outer corner to its left-upper inner corner. For left-to-right OS they are always the widths of left/top borders. For right-to-left OS the vertical scrollbar is on the left so clientLeft includes its width too. clientWidth/clientHeight – the width/height of the content including paddings, but without the scrollbar. scrollWidth/scrollHeight – the width/height of the content including the scrolled out parts. Also includes paddings, but not the scrollbar. scrollLeft/scrollTop – width/height of the scrolled out part of the element, starting from its left-upper corner. All properties are read-only except scrollLeft/scrollTop. They make the browser scroll the element if changed. Don’t take width/height from CSS. We can read CSS-height and width using getComputedStyle. Why should we use geometry properties instead? There are two reasons: CSS width/height depend on another property: box-sizing, CSS width/height may be auto. Some browsers (e.g. Chrome) return the real inner width, minus the scrollbar, and some of them (e.g. Firefox) – CSS width (ignore the scrollbar). Such cross-browser differences is the reason not to use getComputedStyle, but rather rely on geometry properties. Window sizes and scrollingGeometry: Width/height of the visible part of the document (content area width/height):document.documentElement.clientWidth/Height. Width/height of the whole document, with the scrolled out part:12345let scrollHeight = Math.max( document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight); Scrolling: Most browsers provide documentElement.scrollLeft/Top for the document scroll, but Chrome/Safari/Opera have bugs and we should use document.body instead of document.documentElement there. Luckily, we don’t have to remember these peculiarities at all, because of the following special properties: Read the current scroll: window.pageYOffset/pageXOffset. Change the current scroll: window.scrollTo(pageX,pageY) – absolute coordinates, window.scrollBy(x,y) – scroll relative the current place, elem.scrollIntoView(top) – scroll to make elem visible (align with the top/bottom of the window). CoordinatesAny point on the page has coordinates: Relative to the window – elem.getBoundingClientRect(). Relative to the document – elem.getBoundingClientRect() plus the current page scrollwindow.pageXOffset/pageYOffset. Window coordinates are great to use with position:fixed, and document coordinates do well with position:absolute. Both coordinate systems have their “pro” and “contra”, there are times we need one or the other one, just like CSS position absolute and fixed. Words and phrases: out of nowhere 莫名其妙的出现 superposition 叠加]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Arch Linux]]></title>
    <url>%2F2018%2F07%2F18%2FArchlinux%2F</url>
    <content type="text"><![CDATA[Dual Booting Arch Linux / Windows 10 On Surface Pro.Device: Surface Pro 2017OS: Windows 10 / Arch Linux 2018.05.01Method: USB Installer 准备工作熟悉 Vim. 压缩卷右键开始 –&gt; 磁盘管理(K) –&gt; 选择主分区 –&gt; 压缩卷 –&gt; 分出 40 G. 制作启动盘下载 Arch Linux 和 Rufus 并制作好启动盘（选择 UEFI, PT). 设置从 USB 启动首先按住音量键并启动, 入 UEFI, 闭安全启动, 将启动顺序改为从 USB 启动. 插入 USB 后 Reboot 就能从 USB 启动 Arch Linux. 选择第一个选项进入系统. 安装过程安装过程需要使用网络. 用数据线连接手机, 开USB网络共享. 设置屏幕字体大小由于分辨率太高, 致字体显示太小, 新设置终端字体 1# setfont /usr/share/kbd/consolefonts/latarcyrheb-sun32.psfu.gz 测试网络连接 123# dhcpcd# ping -c 3 www.baidu.com // 成功接收到数据包则连接成功# timedatectl set-ntp true 分区 123456789101112# fdisk -l // 以下是一个输出实例nvme0n1 259:0 0 238.5G|- nvme0n1p1 259:1 0 260M|- nvme0n1p2 259:2 0 128M|- nvme0n1p3 259:3 0 174.8G|- nvme0n1p4 259:4 0 830M# gdisk /dev/nvme0n1/*1. n(new) 2. 在last sector时 +20G, 其余回车, 择默认设置 3. n 回车选择默认设置, 出第6部分 4. p 看是否分区成功 5. w(write) Y(Yes)*/ 格式化 12# mkfs.ext4 /dev/nvme0n1p5# mkfs.ext4 /dev/nvme0n1p6 挂载 12345# mount /dev/nvme0n1p5 /mnt# mkdir /mnt/home# mount /dev/nvme0n1p6 /mnt/home# mkdir -p /mnt/boot/efi // 创建 UEFI 挂载点# mount /dev/nvme0n1p1 /mnt/boot/efi // 挂载 UEFI 分区 安装 base 12345# vi /etc/pacman.d/mirrorlist //把163的提到第一个# pacstrap -i /mnt base base-devel# genfstab -U /mnt &gt;&gt; /mnt/etc/fstab# cat /mnt/etc/fstab# arch-chroot /mnt 安装 grub 123# pacman -S dosfstools grub efibootmgr os-prober(双系统必装)# grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=grub# grub-mkconfig -o /boot/grub/grub.cfg //(reboot 后还要运行一次, 行结果才会出现windows manager) 重启 reboot 12345# passwd // 设置 root 密码# CTRL-D // exit# umount /mnt/boot/efi# umount /mnt# reboot // 记得移除 USB 基本设置重启后用 root 身份登录, 修改显示字体, 开手机网络共享, 试网络.123# setfont /usr/share/kbd/consolefonts/latarcyrheb-sun32.psfu.gz# dhcpcd# ping -c 3 www.baidu.com // 成功接收到数据包则连接成功 时区 1# ln -S /usr/share/zoneinfo/Asia/Shanghai /etc/localtime Locale 12345# vi /etc/locale.gen // 移除下面两行前的注释符号en\_US.UTF-8 UTF-8zh\_CN.UTF-8 UTF-8# locale-gen# echo LANG=en_US.UTF-8 &gt; /etc/locale.conf hostname 123456789# echo Arch &gt; /etc/hostname //将主机名Arch填入# vi /etc/hosts // 修改 host完成后看起来像这样:# cat /etc/hostnameArch# cat /etc/hosts127.0.0.1 localhost.localdomain localhost::1 localhost.localdomain localhost127.0.1.1 Arch.localdomain Arch 时间时间表示有两个标准：Localtime 和 UTC(Coordinated Universal Time). UTC 是与时区无关的全球时间标准. 尽管概念上有差别, UTC 和 GMT (格林威治时间) 是一样的. Localtime 标准则依赖于当前时区. 由于 windows 使用 Localtime, 为了保持一致: 12# timedatectl set-local-rtc true // 将硬件时间设置为 localtime# hwclock --systohc // 同步硬件时间和系统时间 网络 123# systemctl enable dhcpcd# pacman -S networkmanager iw wpa_supplicant dialog# systemctl enable NetworkManager 显卡, Touchpad 驱动 12# pacman -S xf86-video-intel# pacman -S xf86-input-libinput gnome 12# pacman -S gnome gnome-tweaks# systemctl enable gdm 重启后 gnome 启动, 登录 root 账户, 在 account setting 中 add users 后, log out 重新以 user 的身份登录. gnome 设置 Touchpad 左键使用不习惯.setting –&gt; devices –&gt; mouse and touchpad –&gt; tab to click;tweaks –&gt; mouse &amp; touchpad –&gt; Mouse click emulation (Area). sudo 12$ sudo pacman -S sudo vim$ visudo //（在 root ALL=(ALL)下面仿照格式把root 改成 username） 添加 archlinuxcn 源 123456$ sudo vim /etc/pacman.conf // 添加以下几行[archlinuxcn]#The Chinese Arch Linux communities packages.SigLevel = Optional TrustAllServer = http://repo.archlinuxcn.org/$arch$ sudo pacman -Syu 搜狗拼音 12345$ sudo pacman -S fcitx-im fcitx-configtool fcitx-sogoupinyin$ sudo vim /etc/environment // 写入export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=@im=fcitx 然后还需要修改 fcitx-configtool 中的设置: Default Keyboard Layout –&gt; 选择 Chinese, 添加 –&gt; Add input method（+号）选择 Sougou Pinyin. chrome 123$ sudo pacman -S wqy-microhei wqy-zenhei yaourt// 字体$ sudo yaourt -S google-chrome // 如果root账号下安装 chrome, chrome 无法启动.$ sudo pacman -R epiphany shadowsocks 1$ sudo pacman -S shadowsocks-qt5 设置好 shadowsock 后, 还需要 setting –&gt; Network –&gt; Network Proxy –&gt; Manual –&gt; Socks Host 127.0.0.1 1080（设置的local端口号）. 桌面美化 下载extensions, 解压缩后, 放到路径：~/.local/share/gnome-shell/extensions/下载Gnome-OSC, 解压缩后, 把里面两个文件, 放到路径：home/.themes/下,下载macOS iCons, 解压缩后, 放到路径：home/.icons/下.重新登录后(重启？), 利用 tweaks 进行设置. 解决休眠问题 123$ sudo vim /etc/systemd/logind.confHandleLidSwitch=ignore$ systemctl restart systemd-logind setting –&gt; power, 关闭 atutosuspend, dim screen. pacman 12$ sudo pacman -Sc // 清除未安装软件包的缓存$ pacman -S archlinux-keyring]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
</search>
